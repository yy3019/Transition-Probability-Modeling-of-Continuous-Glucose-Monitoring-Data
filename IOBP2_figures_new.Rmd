---
title: "IOBP2_figures_new"
author: "Denise, Margaret, Fisher"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_document:
    #toc: true
    #toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(tidyverse)
library(readr)
library(tidyverse)
library(KernSmooth)
library(transport)
library(dplyr)
library(pracma)
library(stats)
library(purrr)
library(patchwork)
library(DT)
library(shiny)
library(ggplot2)
library(dplyr)
library(stats)
library(shinyWidgets)
library(plotly)
library(dplyr)
library(ggsci)
library(np)
library(knitr)
library(kableExtra)
library(tidyverse)
library(KernSmooth)
library(transport)
library(dplyr)
library(pracma)
library(stats)
library(purrr)
library(patchwork)
library(DT)
library(shiny)
library(ggplot2)
library(dplyr)
library(stats)
library(shinyWidgets)
library(plotly)
library(dplyr)
library(ggsci)
library(np)
library(knitr)
library(kableExtra)
library(caret)
library(glmnet)
library(lubridate)
```


### Data Cleaning
```{r}
# count for how many participant in CLC group and SC group
dir_folder = "cgm data/IOBP2_data/"
PtRoster <- read.delim(paste0(dir_folder, "IOBP2PtRoster.txt"), sep = "|", header = TRUE, stringsAsFactors = FALSE)

IOBP2excomClarityCGM <- read.delim(paste0(dir_folder, "IOBP2DeviceCGM.txt"), sep = "|", header = TRUE, stringsAsFactors = FALSE) 


iobp2 = IOBP2excomClarityCGM[,-c(1,4,5,7,8)] %>% left_join(PtRoster[,c(2,5,7,8)])

library(lubridate)
iobp2$DeviceDtTm <- as.POSIXct(iobp2$DeviceDtTm, format = "%m/%d/%Y %H:%M:%S %p", tz = "UTC")
iobp2$RandDt <- as.POSIXct(iobp2$RandDt, format = "%m/%d/%Y %I:%M:%S %p", tz = "UTC")
iobp2$AgeAsofEnrollDt = as.numeric(iobp2$AgeAsofEnrollDt)
iobp2$TrtGroup = as.factor(iobp2$TrtGroup)

iobp2 = iobp2 %>%
  # Classify age group
  mutate(Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")) %>%
  filter(TrtGroup != "BPFiasp")

expected_points_per_week <- 288 * 7 * 4  # 288 intervals/day * 7 days

# Prepare the data (exactly 13 weeks from first measurement after RandDt)
rct = iobp2 %>% filter(DeviceDtTm >= RandDt & DeviceDtTm <=RandDt + weeks(12))



```


### Missingness Plot
##### Keep 80% in all 0-4, 4-8, 8-12
```{r}
library(dplyr)
library(lubridate)

# Expected number of CGM points per 4-week period
expected_points_per_period <- 288 * 7 * 4  # 288 points/day * 7 days/week * 4 weeks = 8064 points
expected_points_per_week = 288*7
# Prepare data (exactly 12 weeks from first measurement after RandDt, 3 periods: 0-4, 4-8, 8-12)
rct_filtered <- rct %>%
  filter(DeviceDtTm >= RandDt, TrtGroup %in% c("Control", "BP")) %>%
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(4) ~ "Weeks 1-4",
      DeviceDtTm >= Start_time + weeks(4) & DeviceDtTm < Start_time + weeks(8) ~ "Weeks 5-8",
      DeviceDtTm >= Start_time + weeks(8) & DeviceDtTm < Start_time + weeks(12) ~ "Weeks 9-12",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(Period)) %>%
  ungroup()


rct_filtered_all <- rct %>%
  filter(DeviceDtTm >= RandDt, TrtGroup %in% c("Control", "BP")) %>%
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(12) ~ "Weeks 1-12",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(Period)) %>%
  ungroup()


# Count actual points per patient per period
coverage_summary <- rct_filtered %>%
  group_by(PtID, TrtGroup, Peds_age, Period) %>%
  summarise(
    actual_points = n(),
    percent_available = actual_points / expected_points_per_period * 100,
    .groups = "drop"
  )

coverage_summary_all <- rct_filtered_all %>%
  group_by(PtID, TrtGroup, Peds_age, Period) %>%
  summarise(
    actual_points = n(),
    percent_available = actual_points / expected_points_per_period * 100,
    .groups = "drop"
  )

# Filter patients with ≥80% coverage in all three periods
patients_good_coverage <- coverage_summary %>%
  filter(percent_available >= 80) %>%
  group_by(PtID, TrtGroup, Peds_age) %>%
  summarise(
    num_good_periods = n(),
    .groups = "drop"
  ) %>%
  filter(num_good_periods == 3)

# Final filtered data
final_filtered_data <- rct_filtered %>%
  filter(PtID %in% patients_good_coverage$PtID)

# Count remaining patients in each group
final_patient_counts <- patients_good_coverage %>%
  group_by(TrtGroup, Peds_age) %>%
  summarise(
    num_patients_remaining = n(),
    .groups = "drop"
  )

# Show results
#final_patient_counts %>%
#  tidyr::pivot_wider(names_from = TrtGroup, values_from = num_patients_remaining, values_fill = 0) %>%
#  knitr::kable(caption = "Number of Patients Remaining (≥80% coverage in all periods)")


# Baseline data processing
baseline_dates <- iobp2 %>%
  filter(DeviceDtTm < RandDt) %>%
  group_by(PtID, RandDt) %>%
  summarise(start_date = min(DeviceDtTm), .groups = "drop") %>%
  mutate(days_in_baseline = as.numeric(difftime(RandDt, start_date, units = "days")))

baseline <- iobp2 %>%
  filter(DeviceDtTm < RandDt) %>%
  left_join(baseline_dates, by = c("PtID", "RandDt")) %>%
  mutate(Rct_period = "Baseline")

points_baseline <- baseline %>%
  group_by(PtID, Rct_period, TrtGroup, Peds_age, days_in_baseline) %>%
  summarise(actual_points = n(), .groups = "drop") %>%
  mutate(
    expected_points = days_in_baseline * expected_points_per_day,
    percent_available = actual_points / expected_points * 100,
    percent_missing = 100 - percent_available
  )

### two cutoff
limited_id = intersect(patients_good_coverage$PtID, points_baseline %>% filter(actual_points > expected_points_per_week * 2) %>% pull(PtID))

bigger_id = patients_good_coverage$PtID
```

### Table
```{r}
dir_folder = "cgm data/IOBP2_data/"
HB_results <- read.delim(paste0(dir_folder, "STASampleResults.txt"), sep = "|", header = TRUE, stringsAsFactors = FALSE) %>% filter(ResultName == "GLYHB")


HB_results[,c(2,3,7)] %>% filter(PtID %in% limited_id ) %>%
  pivot_wider(names_from = Visit, values_from = Value) %>%
  left_join(PtRoster[,c(2,5,7,8)]) %>%
  filter(TrtGroup != "BPFiasp") %>%
  mutate(Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")) %>%
  group_by(TrtGroup, Peds_age) %>%
  mutate(
    Randomization = as.numeric(Randomization),
    `Week 6` = as.numeric(`Week 6`),
    `Week 13` = as.numeric(`Week 13`)
  ) %>%
  summarise(
    random = sprintf("%.3f (%.3f)", mean(Randomization, na.rm = TRUE), sd(Randomization, na.rm = TRUE)),
    week_6 = sprintf("%.3f (%.3f)", mean(`Week 6`, na.rm = TRUE), sd(`Week 6`, na.rm = TRUE)),
    week_13 = sprintf("%.3f (%.3f)", mean(`Week 13`, na.rm = TRUE), sd(`Week 13`, na.rm = TRUE)),
    .groups = "drop"
  )


hb_wide <- HB_results[,c(2,3,7)] %>% filter(PtID %in% limited_id ) %>%
  pivot_wider(names_from = Visit, values_from = Value) %>%
  left_join(PtRoster[,c(2,5,7,8)]) %>%
  filter(TrtGroup != "BPFiasp") %>%
  mutate(Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")) %>%
  mutate(
    Randomization = as.numeric(Randomization),
    `Week 6` = as.numeric(`Week 6`),
    `Week 13` = as.numeric(`Week 13`)
  )

# Function to get p-value for a variable by age group
get_pval <- function(var, age_group) {
  dat <- hb_wide %>% filter(Peds_age == age_group)
  wilcox.test(as.formula(paste(var, "~ TrtGroup")), data = dat)$p.value
}

# Adults
pval_adults_rand <- get_pval("Randomization", "adults")
pval_adults_week6 <- get_pval("`Week 6`", "adults")
pval_adults_week13 <- get_pval("`Week 13`", "adults")

# Children
pval_children_rand <- get_pval("Randomization", "children")
pval_children_week6 <- get_pval("`Week 6`", "children")
pval_children_week13 <- get_pval("`Week 13`", "children")

# Print out all p-values rounded
cat("Adults Randomization p-value:", format.pval(pval_adults_rand, digits=3), "\n")
cat("Adults Week 6 p-value:", format.pval(pval_adults_week6, digits=3), "\n")
cat("Adults Week 13 p-value:", format.pval(pval_adults_week13, digits=3), "\n\n")
cat("Children Randomization p-value:", format.pval(pval_children_rand, digits=3), "\n")
cat("Children Week 6 p-value:", format.pval(pval_children_week6, digits=3), "\n")
cat("Children Week 13 p-value:", format.pval(pval_children_week13, digits=3), "\n")


```


### Plot
```{r, fig.height=20, fig.width=20}
expected_points_per_day <- 288
expected_points_per_week <- expected_points_per_day * 7

points_rct <- rct_filtered %>%
  group_by(PtID, Period, TrtGroup, Peds_age) %>%
  summarise(actual_points = n(), .groups = "drop") %>%
  mutate(
    expected_points = expected_points_per_week * 4,
    percent_available = actual_points / expected_points * 100,
    percent_missing = 100 - percent_available
  )

points_rct_all <- rct_filtered_all %>%
  group_by(PtID, Period, TrtGroup, Peds_age) %>%
  summarise(actual_points = n(), .groups = "drop") %>%
  mutate(
    expected_points = expected_points_per_week * 12,
    percent_available = actual_points / expected_points * 100,
    percent_missing = 100 - percent_available
  )

# Combine baseline and RCT
combined_points <- bind_rows(points_rct_all, points_rct)


period_levels <- c("Weeks 1-12", "Weeks 1-4", "Weeks 5-8", "Weeks 9-12")


# --- Step 1: Mark patients who have good coverage in ALL RCT periods ---
patients_good_coverage <- points_rct %>%
  filter(percent_available >= 80) %>%
  group_by(PtID, TrtGroup, Peds_age) %>%
  summarise(num_good_periods = n(), .groups = "drop") %>%
  filter(num_good_periods == 3)

# --- Step 2: Patient-level exclusion status (for whole row box) ---
combined_points <- combined_points %>%
  mutate(
    excluded_individual = !(PtID %in% patients_good_coverage$PtID)
  )

# --- Step 3: Pre-compute the coordinates for boxes (whole rows) ---
row_boxes <- combined_points %>%
  filter(excluded_individual) %>%
  distinct(PtID, TrtGroup, Peds_age) %>%
  mutate(
    y = reorder(factor(PtID), -as.numeric(as.character(PtID)))
  )

all_patients <- combined_points %>% distinct(PtID, TrtGroup, Peds_age)
all_periods <- tibble(Period = period_levels)

all_combos <- crossing(all_patients, all_periods)

# Join your missingness data onto this full grid
plot_data_full <- all_combos %>%
  left_join(combined_points, by = c("PtID", "TrtGroup", "Peds_age", "Period")) %>%
  mutate(
    percent_missing = ifelse(is.na(percent_missing), 100, percent_missing), # Make fully missing = black
    excluded_individual = ifelse(is.na(excluded_individual), TRUE, excluded_individual)
  )

# Calculate counts of original and excluded patients by treatment/age
summary_counts <- plot_data_full %>%
  group_by(TrtGroup, Peds_age) %>%
  summarise(
    N_original = n_distinct(PtID),
    N_removed = n_distinct(PtID[excluded_individual])
  ) %>%
  ungroup()

# Redefine plotting function to use this full data
plot_missingness_points <- function(data, age_group, treatment, n_original, n_removed) {
  plot_data <- data %>%
    filter(Peds_age == age_group, TrtGroup == treatment)

  box_patients <- plot_data %>%
    filter(excluded_individual) %>%
    distinct(PtID) %>%
    pull(PtID)

  ggplot(plot_data, aes(
    x = factor(Period, levels = period_levels),
    y = factor(PtID, levels = rev(sort(unique(PtID))))
  )) +
    geom_tile(aes(fill = percent_missing), color = "grey90") +
    # Add gold box around the whole row for excluded individuals
    geom_rect(
      data = plot_data %>% filter(PtID %in% box_patients) %>% distinct(PtID),
      inherit.aes = FALSE,
      aes(
        xmin = 0.5, xmax = length(period_levels) + 0.5,
        ymin = as.numeric(factor(PtID, levels = rev(sort(unique(plot_data$PtID))))) - 0.5,
        ymax = as.numeric(factor(PtID, levels = rev(sort(unique(plot_data$PtID))))) + 0.5
      ),
      color = "#d73027", fill = NA, linewidth = 1.2, linejoin = "mitre", alpha = 0.85
    ) +
    scale_fill_gradient2(
      low = "white", mid = "darkgrey", high = "black",
      midpoint = 20, limits = c(0, 100),
      name = "Missingness (%)"
    ) +
    labs(
      title = paste0("CGM Missingness: ", treatment, " - ", age_group,
                     " (Original N = ", n_original, "; Removed N = ", n_removed, ")"),
      x = "Period",
      y = "Patient ID"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      axis.text.y = element_text(size = 12),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )
}


# Use the full data set for all four plots:
get_counts <- function(treatment, age_group) {
  summary_counts %>%
    filter(TrtGroup == treatment, Peds_age == age_group) %>%
    select(N_original, N_removed) %>%
    as.list()
}

bp_adults_counts    <- get_counts("BP", "adults")
bp_children_counts  <- get_counts("BP", "children")
control_adults_counts   <- get_counts("Control", "adults")
control_children_counts <- get_counts("Control", "children")

plot_bp_adults <- plot_missingness_points(plot_data_full, "adults", "BP",
  n_original = bp_adults_counts$N_original, n_removed = bp_adults_counts$N_removed)
plot_bp_children <- plot_missingness_points(plot_data_full, "children", "BP",
  n_original = bp_children_counts$N_original, n_removed = bp_children_counts$N_removed)
plot_control_adults <- plot_missingness_points(plot_data_full, "adults", "Control",
  n_original = control_adults_counts$N_original, n_removed = control_adults_counts$N_removed)
plot_control_children <- plot_missingness_points(plot_data_full, "children", "Control",
  n_original = control_children_counts$N_original, n_removed = control_children_counts$N_removed)


combined_plot <- (plot_bp_adults + plot_bp_children) /
                 (plot_control_adults + plot_control_children) +
  plot_layout(widths = c(1, 1), heights = c(2, 1))

combined_plot

ggsave("./figures/CGM_Missingness_By_Period.png", plot = combined_plot,
       width = 20, height = 30, dpi = 300)
```

### Marginal Probability - bigger id
```{r}
library(dplyr)
library(ggplot2)
library(ggsci)

iobp2_f1 = iobp2 %>% filter(PtID %in% bigger_id) %>% filter(DeviceDtTm < RandDt + weeks(12))%>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      DeviceDtTm >= RandDt & DeviceDtTm < RandDt + weeks(12) ~ "RCT",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

# Set the order of glycemic states (from highest to lowest)
desired_levels <- c(
  "Level 2 hyperglycemia", 
  "Level 1 hyperglycemia", 
  "In range", 
  "Level 1 hypoglycemia", 
  "Level 2 hypoglycemia"
)

# Make Level a factor with the desired order
proportions_by_group <- iobp2_f1 %>%
  mutate(Level = factor(Level, levels = desired_levels)) %>%
  group_by(TrtGroup, Rct_period, Level, Peds_age) %>%
  tally() %>%
  group_by(TrtGroup, Rct_period, Peds_age) %>%
  mutate(Proportion = n / sum(n),
         TrtGroup = factor(TrtGroup, level = c("Control","BP"))) %>%
  ungroup() %>%
  select(TrtGroup, Rct_period, Peds_age, Level, Proportion)


# Bar plot with ordered levels
p_plot = ggplot(proportions_by_group, aes(x = TrtGroup, y = Proportion, fill = Level)) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  facet_grid(Peds_age ~ Rct_period, scales = "free_x") +
  labs(
    title = "Marginal Probabilities of Glycemic States by Treatment, Period, and Age Group",
    x = "Period",
    y = "Proportion",
    fill = "Glycemic State"
  ) +
  scale_fill_npg() +
  theme_classic(base_size = 24) +
  geom_text(
    aes(label = scales::percent(Proportion, accuracy = 0.1)),
    position = position_dodge(width = 1), vjust = -0.8, size = 6
  ) +
  theme(axis.text.x = element_text(), legend.position = "bottom") + ylim(0, 0.8)

ggsave("./figures/Marginal_Probability.png",
       p_plot, width = 17, height = 10, dpi = 300)

p_plot

```

### With-in Participants Transition Probability - limited id
```{r, fig.height=12, fig.width=16}

library(dplyr)
library(lubridate)
library(purrr)
library(tidyr)
library(markovchain)
library(ggplot2)
library(patchwork)
library(forcats)

set.seed(777)

# 1. Define transition levels
states_order <- c("Level 2 hyperglycemia", "Level 1 hyperglycemia", "In range", "Level 1 hypoglycemia", "Level 2 hypoglycemia")
short_names <- c(
  "Level 2 hypoglycemia" = "L2 Hypo",
  "Level 1 hypoglycemia" = "L1 Hypo",
  "In range" = "In Range",
  "Level 1 hyperglycemia" = "L1 Hyper",
  "Level 2 hyperglycemia" = "L2 Hyper"
)

# 2. Data: Filter and create state labels
iobp2_f2_within <- iobp2 %>%
  filter(PtID %in% limited_id) %>%
  filter(DeviceDtTm < RandDt + weeks(12)) %>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      DeviceDtTm >= RandDt & DeviceDtTm < RandDt + weeks(12) ~ "RCT",
      TRUE ~ NA_character_
    ),
    Level = factor(case_when(
      Value >= 250 ~ "Level 2 hyperglycemia",
      Value >= 181 ~ "Level 1 hyperglycemia",
      Value >= 70  ~ "In range",
      Value >= 54  ~ "Level 1 hypoglycemia",
      Value <  54  ~ "Level 2 hypoglycemia"
    ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                  "Level 1 hyperglycemia", "Level 2 hyperglycemia"))
  )

# 3. Transition matrix function
calculate_transitions1 <- function(data, max_gap_mins = 120) {
  #data <- data[order(data$DeviceDtTm), ]
  n <- nrow(data)
  if (n < 2 || length(unique(data$Level)) < 2) return(NULL)
  data$time_diff <- c(0, as.numeric(difftime(data$DeviceDtTm[-1], data$DeviceDtTm[-n], units = "mins")))
  valid_idx <- which(data$time_diff[-1] <= max_gap_mins) + 1
  if (length(valid_idx) < 1) return(NULL)
  from_states <- as.character(data$Level[valid_idx - 1])
  to_states   <- as.character(data$Level[valid_idx])
  trans_table <- table(from_states, to_states)
  if (all(dim(trans_table) == 0)) return(NULL)
  transition_matrix <- prop.table(trans_table, 1)
  desired_order <- states_order
  transition_matrix_full <- matrix(0, nrow = length(desired_order), ncol = length(desired_order),
                                   dimnames = list(desired_order, desired_order))
  transition_matrix_full[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix
  return(transition_matrix_full)
}

# 4. Construct wide-form per-subject data
indiv_wide <- iobp2_f2_within %>%
  group_by(PtID, TrtGroup, Peds_age, Rct_period) %>%
  arrange(DeviceDtTm, .by_group = TRUE) %>%
  group_modify(~ tibble(transitionMatrix = list(calculate_transitions1(.x)))) %>%
  ungroup() %>%
  pivot_wider(names_from = Rct_period, values_from = transitionMatrix) %>%
  filter(!map_lgl(Baseline, is.null), !map_lgl(RCT, is.null))

# Helper: Align matrices to order
align_matrix <- function(mat) {
  m <- matrix(0, 5, 5, dimnames = list(states_order, states_order))
  if (!is.null(mat)) {
    rows <- intersect(states_order, rownames(mat))
    cols <- intersect(states_order, colnames(mat))
    m[rows, cols] <- mat[rows, cols, drop = FALSE]
  }
  m
}

get_stationary_dist <- function(mat) {
  for (i in 1:nrow(mat)) {
    row_sum <- sum(mat[i, ], na.rm = TRUE)
    if (row_sum > 0) mat[i, ] <- mat[i, ] / row_sum
  }
  mc <- tryCatch(new("markovchain", states = states_order, transitionMatrix = mat, name = "Chain"), error = function(e) NULL)
  if (is.null(mc)) return(rep(NA, length(states_order)))
  stat <- tryCatch(as.numeric(steadyStates(mc)[1, ]), error = function(e) rep(NA, length(states_order)))
  names(stat) <- states_order
  stat
}

# Correct bootstrap: center differences under null!
bootstrap_pval_within <- function(baseline_vals, rct_vals, R = 1000) {
  idx <- which(!is.na(baseline_vals) & !is.na(rct_vals))
  baseline_vals <- baseline_vals[idx]
  rct_vals <- rct_vals[idx]
  if (length(baseline_vals) < 2) return(NA_real_)
  obs_diffs <- rct_vals - baseline_vals
  obs_mean <- mean(obs_diffs)
  centered_diffs <- obs_diffs - mean(obs_diffs)
  boot_means <- replicate(R, mean(sample(centered_diffs, replace = TRUE)))
  pval <- mean(abs(boot_means) >= abs(obs_mean))
  pval
}

extract_transition_value <- function(mat, from_state, to_state) {
  if (is.null(mat)) return(NA_real_)
  if (!(from_state %in% rownames(mat) && to_state %in% colnames(mat))) return(NA_real_)
  mat[from_state, to_state]
}

# Main plotting function (as before, improved pval logic)
# ... [your data processing code is unchanged up to plotting function] ...

# --- Calculate global scale per age group ---

# Helper: for each (trt, age), get the difference matrix
get_diff_matrix <- function(indiv_wide, trt, age) {
  subdat <- indiv_wide %>% filter(TrtGroup == trt, Peds_age == age)
  n_indiv <- nrow(subdat)
  if (n_indiv == 0) return(matrix(0, nrow=5, ncol=5))
  baseline_mats <- map(subdat$Baseline, align_matrix)
  rct_mats      <- map(subdat$RCT, align_matrix)
  mean_base <- Reduce(`+`, baseline_mats) / n_indiv
  mean_rct  <- Reduce(`+`, rct_mats) / n_indiv
  mean_rct - mean_base
}

# Calculate and print difference matrices for each group
for (trt in c("BP", "Control")) {
  for (age in c("adults", "children")) {
    cat("\n--- Difference in transition matrix for", trt, "-", age, "---\n")
    diff_mat <- get_diff_matrix(indiv_wide, trt, age)
    # Round to three decimals for readability
    print(round(diff_mat, 3))
  }
}


# For each age group, get the max absolute value across both treatment arms
age_groups <- c("adults", "children")
limits_by_age <- list()

for (age in age_groups) {
  diff_BP <- get_diff_matrix(indiv_wide, "BP", age)
  diff_Ctrl <- get_diff_matrix(indiv_wide, "Control", age)
  max_val <- max(abs(c(diff_BP, diff_Ctrl)), na.rm = TRUE)
  # A little padding
  limits_by_age[[age]] <- round(max_val, 3) + 0.01
}

# --- Modify plot function to accept color_limit argument ---

plot_within_indiv_transition_diff <- function(indiv_wide, trt, age, R = 1000, color_limit = NULL) {
  subdat <- indiv_wide %>% filter(TrtGroup == trt, Peds_age == age)
  n_indiv <- nrow(subdat)
  if (n_indiv == 0) return(NULL)
  baseline_mats <- map(subdat$Baseline, align_matrix)
  rct_mats      <- map(subdat$RCT, align_matrix)
  mean_base <- Reduce(`+`, baseline_mats) / n_indiv
  mean_rct  <- Reduce(`+`, rct_mats) / n_indiv
  marginal_base <- get_stationary_dist(mean_base)
  marginal_rct  <- get_stationary_dist(mean_rct)
  fmt_pct <- function(x) sprintf("%.1f%%", 100 * x)
  y_labels <- sprintf("%s (%s, %s)", states_order, fmt_pct(marginal_base), fmt_pct(marginal_rct))
  names(y_labels) <- states_order
  diff_matrix <- mean_rct - mean_base

  plot_df <- expand.grid(From = states_order, To = states_order, stringsAsFactors = FALSE) %>%
    mutate(
      Diff = mapply(function(f, t) diff_matrix[f, t], From, To),
      Pval = NA_real_
    )
  for (i in seq_len(nrow(plot_df))) {
    f <- plot_df$From[i]
    t <- plot_df$To[i]
    base_vals <- purrr::map_dbl(baseline_mats, extract_transition_value, from_state = f, to_state = t)
    rct_vals  <- purrr::map_dbl(rct_mats, extract_transition_value, from_state = f, to_state = t)
    plot_df$Pval[i] <- bootstrap_pval_within(base_vals, rct_vals, R = R)
  }
  plot_df <- plot_df %>%
    mutate(
      Star = cut(Pval, breaks = c(-Inf, 0.001, 0.01, 0.05, Inf), labels = c("***", "**", "*", ""), right = TRUE),
      ToShort = short_names[To],
      From = factor(From, levels = rev(states_order)),
      ToShort = factor(ToShort, levels = rev(short_names[states_order]))
    )

  # Use supplied color limit
  if (is.null(color_limit)) {
    color_limit <- max(abs(plot_df$Diff), na.rm = TRUE) %>% round(3) + 0.01
  }

  p <- ggplot(plot_df, aes(x = ToShort, y = From, fill = Diff)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Star), size = 7, color = "black", fontface = "bold", lineheight = 0.8, na.rm = TRUE) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         midpoint = 0, limits = c(-color_limit, color_limit),
                         name = "RCT - Baseline") +
    scale_y_discrete(labels = y_labels[rev(states_order)]) +
    labs(
      title = sprintf("Within-Individual Transition Change: %s, %s (n=%d)", trt, tools::toTitleCase(age), n_indiv),
      x = "To State", y = "From State (Baseline %, RCT %)"
    ) +
    theme_minimal(base_size = 15) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          axis.text.y = element_text(size = 15),
          plot.title = element_text(size = 16, face = "bold", hjust = 0.5))
  return(p)
}

# --- Generate plots with the correct limit for each age group ---

plots <- list()
for (trt in c("BP", "Control")) {
  for (age in age_groups) {
    plots[[paste(trt, age, sep = "_")]] <-
      plot_within_indiv_transition_diff(indiv_wide, trt, age, R = 1000, color_limit = limits_by_age[[age]])
  }
}

final_plot <- (plots[["BP_adults"]] | plots[["BP_children"]]) /
              (plots[["Control_adults"]] | plots[["Control_children"]]) +
  patchwork::plot_annotation(
    title = "Within-Individual Changes in Transition Probabilities (RCT - Baseline)",
    subtitle = "Y-axis: (Baseline %, RCT %). Stars: *, **, *** = p < 0.05, 0.01, 0.001"
  )

ggsave("./figures/transition_probability_diff_RCT_vs_Baseline_PtID_2weeks.png", final_plot, width = 18, height = 9, dpi = 300)
final_plot



```
##### print p-value
```{r}
# Print actual p-values for each transition, by treatment and age group
print_transition_pvals <- function(indiv_wide, trt, age) {
  cat("\n--- P-values for within-individual transition probability differences ---\n")
  cat(sprintf("Group: %s | Age: %s\n", trt, age))
  subdat <- indiv_wide %>% filter(TrtGroup == trt, Peds_age == age)
  if (nrow(subdat) == 0) {
    cat("No data for this group.\n")
    return()
  }
  baseline_mats <- map(subdat$Baseline, align_matrix)
  rct_mats      <- map(subdat$RCT, align_matrix)
  for (from_state in states_order) {
    for (to_state in states_order) {
      base_vals <- purrr::map_dbl(baseline_mats, extract_transition_value, from_state = from_state, to_state = to_state)
      rct_vals  <- purrr::map_dbl(rct_mats, extract_transition_value, from_state = from_state, to_state = to_state)
      pval <- bootstrap_pval_within(base_vals, rct_vals, R = 1000)
      cat(sprintf("From %-22s to %-22s : p = %.3f\n", from_state, to_state, pval))
    }
  }
}

# Usage example: print for BP adults, BP children, Control adults, Control children
for (trt in c("BP", "Control")) {
  for (age in c("adults", "children")) {
    print_transition_pvals(indiv_wide, trt, age)
  }
}

```

### group level diff - bigger id
```{r}





limited_id = intersect(patients_good_coverage$PtID, points_baseline %>% filter(actual_points > expected_points_per_week * 2) %>% pull(PtID))

base2 = iobp2 %>% filter(PtID %in% limited_id) %>% filter(DeviceDtTm < RandDt)%>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))
```


```{r, fig.height=12, fig.width=20, eval=FALSE}
library(markovchain)
library(dplyr)
library(tidyr)
library(purrr)
library(knitr)

min1 = points_baseline %>% filter(actual_points > expected_points_per_week * 2) %>% pull(PtID)
base1 = iobp2 %>% filter(PtID %in% min1) %>% filter(DeviceDtTm < RandDt)%>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

# Filter and label the data
iobp2_f1_rct <- rct %>%
  filter(PtID %in% bigger_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(12) ~ "RCT",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

iobp2_f1_rct_d = rct %>%
  filter(PtID %in% bigger_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(4) ~ "Weeks 1-4",
      DeviceDtTm >= Start_time + weeks(4) & DeviceDtTm < Start_time + weeks(8) ~ "Weeks 5-8",
      DeviceDtTm >= Start_time + weeks(8) & DeviceDtTm < Start_time + weeks(12) ~ "Weeks 9-12",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

# Step 2: Improved function to calculate individual transition matrix with gap exclusion
calculate_transitions1 <- function(data, max_gap_mins = 120) {
  # Order by timestamp
  data <- data[order(data$DeviceDtTm), ]
  n <- nrow(data)
  if (n < 2 || length(unique(data$Level)) < 2) return(NULL)

  # Compute time difference (in minutes) between consecutive points
  data$time_diff <- c(0, as.numeric(difftime(data$DeviceDtTm[-1], data$DeviceDtTm[-n], units = "mins")))

  # Identify valid transitions (gap <= max_gap_mins)
  valid_idx <- which(data$time_diff[-1] <= max_gap_mins) + 1  # +1 because diff shifts index
  if (length(valid_idx) < 1) return(NULL)

  # Subset to valid transitions only
  from_states <- as.character(data$Level[valid_idx - 1])
  to_states <- as.character(data$Level[valid_idx])

  # Build table of observed transitions
  trans_table <- table(from_states, to_states)

  # Convert to probability matrix (Markov chain)
  if (all(dim(trans_table) == 0)) return(NULL)
  transition_matrix <- prop.table(trans_table, 1)

  # Ensure all levels present (even if not observed in this subject)
  desired_order <- c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range", "Level 1 hyperglycemia", "Level 2 hyperglycemia")
  transition_matrix_full <- matrix(0, nrow = length(desired_order), ncol = length(desired_order),
                                  dimnames = list(desired_order, desired_order))
  transition_matrix_full[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix

  return(transition_matrix_full)
}

average_transition_matrix_detailed <- function(transitions) {
  desired_order <- c(
    "Level 2 hypoglycemia", "Level 1 hypoglycemia",
    "In range", "Level 1 hyperglycemia", "Level 2 hyperglycemia"
  )
  n_states <- length(desired_order)

  summed_matrices <- matrix(0, n_states, n_states,
                            dimnames = list(desired_order, desired_order))
  state_counts <- setNames(rep(0, n_states), desired_order)

  for (matrix in transitions$transitionMatrix) {
    if (!is.null(matrix)) {
      row_names <- rownames(matrix)
      col_names <- colnames(matrix)
      row_indices <- match(row_names, desired_order)
      col_indices <- match(col_names, desired_order)

      aligned_matrix <- matrix(0, n_states, n_states,
                               dimnames = list(desired_order, desired_order))
      aligned_matrix[row_indices, col_indices] <- matrix

      for (i in seq_along(desired_order)) {
        state <- desired_order[i]
        if (state %in% row_names) {
          summed_matrices[state, ] <- summed_matrices[state, ] + aligned_matrix[state, ]
          state_counts[state] <- state_counts[state] + 1
        }
      }
    }
  }

  mean_matrix <- matrix(0, n_states, n_states,
                        dimnames = list(desired_order, desired_order))
  for (state in desired_order) {
    if (state_counts[state] > 0) {
      mean_matrix[state, ] <- summed_matrices[state, ] / state_counts[state]
    }
  }
  return(mean_matrix)
}
# Step 4: Apply to individuals and group

iobp2_f1 = rbind(base1 %>% dplyr::select(-AgeAsofEnrollDt), iobp2_f1_rct)

individual_transitions_td_base_rct <- iobp2_f1 %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# Step 4: Apply to individuals and group
individual_transitions_td_detail_rct <- iobp2_f1_rct_d %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()



set.seed(666)

# --- States & Labels ---
states_order_long <- c(
  "Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
  "Level 1 hyperglycemia", "Level 2 hyperglycemia"
)
short_names <- c(
  "Level 2 hypoglycemia" = "L2 Hypo",
  "Level 1 hypoglycemia" = "L1 Hypo",
  "In range" = "In Range",
  "Level 1 hyperglycemia" = "L1 Hyper",
  "Level 2 hyperglycemia" = "L2 Hyper"
)

# --- Helper for matrix extraction ---
extract_transition_value <- function(mat, from_state, to_state) {
  if (is.null(mat)) return(NA_real_)
  if (!(from_state %in% rownames(mat) && to_state %in% colnames(mat))) return(NA_real_)
  mat[from_state, to_state]
}

# --- Function to align matrices ---
align_matrix <- function(mat, states) {
  aligned_mat <- matrix(0, length(states), length(states), dimnames = list(states, states))
  if (!is.null(mat)) {
    rows <- intersect(states, rownames(mat))
    cols <- intersect(states, colnames(mat))
    aligned_mat[rows, cols] <- mat[rows, cols]
  }
  aligned_mat
}

# --- Calculate average transition matrix ---
average_transition_matrix <- function(transitions) {
  desired_order <- states_order_long
  n_states <- length(desired_order)
  summed_matrices <- matrix(0, n_states, n_states, dimnames = list(desired_order, desired_order))
  state_counts <- setNames(rep(0, n_states), desired_order)
  for (mat in transitions$transitionMatrix) {
    if (!is.null(mat)) {
      row_names <- rownames(mat)
      col_names <- colnames(mat)
      row_indices <- match(row_names, desired_order)
      col_indices <- match(col_names, desired_order)
      if (all(!is.na(row_indices)) && all(!is.na(col_indices))) {
        aligned_matrix <- matrix(0, n_states, n_states, dimnames = list(desired_order, desired_order))
        aligned_matrix[row_indices, col_indices] <- mat
        for (i in seq_along(desired_order)) {
          state <- desired_order[i]
          if (state %in% row_names) {
            summed_matrices[state, ] <- summed_matrices[state, ] + aligned_matrix[state, ]
            state_counts[state] <- state_counts[state] + 1
          }
        }
      }
    }
  }
  mean_matrix <- matrix(0, n_states, n_states, dimnames = list(desired_order, desired_order))
  for (state in desired_order) {
    if (state_counts[state] > 0) {
      mean_matrix[state, ] <- summed_matrices[state, ] / state_counts[state]
    }
  }
  mean_matrix
}

# --- Bootstrap p-values for each cell (for significance stars) ---
bootstrap_cell_pvals <- function(data, from_state, to_state, group1, group2, R = 1000) {
  diffs <- replicate(R, {
    sample_g1 <- sample(unique(data$PtID[data$TrtGroup == group1]), replace = TRUE)
    sample_g2 <- sample(unique(data$PtID[data$TrtGroup == group2]), replace = TRUE)
    mats_g1 <- data %>% filter(PtID %in% sample_g1) %>% pull(transitionMatrix)
    mats_g2 <- data %>% filter(PtID %in% sample_g2) %>% pull(transitionMatrix)
    val_g1 <- mean(purrr::map_dbl(mats_g1, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g2 <- mean(purrr::map_dbl(mats_g2, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g1 - val_g2
  })
  2 * min(mean(diffs >= 0), mean(diffs <= 0))
}

# Function to safely get stationary distribution
get_stationary_dist <- function(transition_matrix, states) {
  # Ensure valid row sums
  tm <- transition_matrix
  for (i in seq_len(nrow(tm))) {
    row_sum <- sum(tm[i, ], na.rm = TRUE)
    if (row_sum > 0) {
      tm[i, ] <- tm[i, ] / row_sum
    } else {
      tm[i, ] <- 0
    }
  }
  mc <- tryCatch(
    new("markovchain", states = states, transitionMatrix = tm, name = "Chain"),
    error = function(e) NULL
  )
  if (!is.null(mc)) {
    stat <- tryCatch({
      s <- steadyStates(mc)
      as.numeric(s[1,])
    }, error = function(e) rep(NA, length(states)))
    names(stat) <- states
    return(stat)
  } else {
    return(rep(NA, length(states)))
  }
}



# ...[PREVIOUS CODE UNCHANGED: functions and data prep]...

# Compute global_limit SEPARATELY for adults and children
get_group_diff_vals <- function(data, age, periods, group1 = "BP", group2 = "Control") {
  all_diffs <- c()
  for (period in periods) {
    subdata <- data %>% filter(Peds_age == age, Rct_period == period)
    mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
    mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
    tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
    tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
    diff_matrix <- tm_bp - tm_ctrl
    all_diffs <- c(all_diffs, as.vector(diff_matrix))
  }
  max(abs(all_diffs), na.rm = TRUE) %>% round(2) + 0.01
}

age_groups <- c("adults", "children")
periods <- c("Baseline", "RCT", "Weeks 1-4", "Weeks 5-8", "Weeks 9-12")

global_limits <- list()
for (age in age_groups) {
  global_limits[[age]] <- get_group_diff_vals(
    rbind(individual_transitions_td_base_rct, individual_transitions_td_detail_rct),
    age, periods, "BP", "Control"
  )
}

# --- Function to create enhanced heatmap with given global_limit (as before) ---
create_enhanced_heatmap <- function(data, age, period, group1 = "BP", group2 = "Control", R = 1000, global_limit) {
  subdata <- data %>% filter(Peds_age == age, Rct_period == period)
  mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
  mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
  tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
  tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))

  marginal_bp <- get_stationary_dist(tm_bp, states_order_long)
  marginal_ctrl <- get_stationary_dist(tm_ctrl, states_order_long)

  fmt_pct <- function(x) {
    x100 <- 100 * x
    x100 <- pmax(x100, 0.1)
    sprintf("%.1f%%", x100)
  }
  y_labels <- sprintf("%s (%s, %s)", states_order_long, fmt_pct(marginal_ctrl), fmt_pct(marginal_bp))
  names(y_labels) <- states_order_long

  diff_matrix <- tm_bp - tm_ctrl
  diff_df <- as.data.frame(as.table(diff_matrix))
  colnames(diff_df) <- c("From", "To", "Diff")
  diff_df$From <- factor(diff_df$From, levels = states_order_long)
  diff_df$To <- factor(diff_df$To, levels = states_order_long)

  diff_df$Pval <- NA_real_
  for (i in 1:nrow(diff_df)) {
    from <- as.character(diff_df$From[i])
    to <- as.character(diff_df$To[i])
    diff_df$Pval[i] <- tryCatch(
      bootstrap_cell_pvals(subdata, from, to, group1, group2, R = R),
      error = function(e) NA_real_
    )
  }
  diff_df$Star <- cut(diff_df$Pval,
                      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
                      labels = c('***', '**', '*', ''),
                      right = TRUE)

  # SHORT X-axis labels
  short_names <- c(
    "Level 2 hypoglycemia" = "L2 Hypo",
    "Level 1 hypoglycemia" = "L1 Hypo",
    "In range" = "In Range",
    "Level 1 hyperglycemia" = "L1 Hyper",
    "Level 2 hyperglycemia" = "L2 Hyper"
  )

  p <- ggplot(diff_df, aes(x = To, y = From, fill = Diff)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Star), color = "black", size = 6) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         midpoint = 0, limits = c(-global_limit, global_limit),
                         name = "Diff (BP - Control)") +
    scale_y_discrete(labels = y_labels[levels(diff_df$From)]) +
    scale_x_discrete(labels = short_names[levels(diff_df$To)]) +
    labs(
      title = paste0("Age: ", tools::toTitleCase(age), " | Period: ", period),
      x = "To State", y = "From State (Control %, BP %)"
    ) +
    theme_minimal(base_size = 15) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
          axis.text.y = element_text(size = 12))
  return(p)
}

# --- Generate plots with separate color scales for adults/children ---
plot_list <- list()
for (age in age_groups) {
  for (period in periods) {
    plot_list[[paste(age, period, sep = "_")]] <- create_enhanced_heatmap(
      rbind(individual_transitions_td_base_rct, individual_transitions_td_detail_rct),
      age = age,
      period = period,
      group1 = "BP",
      group2 = "Control",
      R = 1000,
      global_limit = global_limits[[age]]
    )
  }
}

# --- Combine all plots as before ---
final_plot <- wrap_plots(plot_list, ncol = 2, byrow = FALSE) +
  plot_annotation(
    title = "Differences in Transition Probabilities (BP - Control) with Significance",
    subtitle = "Separate color scales for Adults and Children. *, **, ***: p < 0.05, 0.01, 0.001"
  )

ggsave("./figures/transition_probability_diff_heatmaps_significance.png",
       final_plot, width = 16, height = 18, dpi = 300)

final_plot

```

### transition probability. - treatment group -level diff - (heatmap)- bigger
```{r, fig.height=12, fig.width=20}
# --- Libraries ---
library(markovchain)
library(dplyr)
library(tidyr)
library(purrr)
library(knitr)
library(ggplot2)
library(patchwork)

# --- States ---
states_order_long <- c(
  "Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
  "Level 1 hyperglycemia", "Level 2 hyperglycemia"
)
short_names <- c(
  "Level 2 hypoglycemia" = "L2 Hypo",
  "Level 1 hypoglycemia" = "L1 Hypo",
  "In range" = "In Range",
  "Level 1 hyperglycemia" = "L1 Hyper",
  "Level 2 hyperglycemia" = "L2 Hyper"
)

# --- Step 1: Prepare Data ---
min1 = points_baseline %>% filter(actual_points > expected_points_per_week * 2) %>% pull(PtID)
base1 = iobp2 %>% filter(PtID %in% min1) %>% filter(DeviceDtTm < RandDt)%>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

# Filter and label the data
iobp2_f1_rct <- rct %>%
  filter(PtID %in% bigger_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(12) ~ "RCT",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

iobp2_f1_rct_d = rct %>%
  filter(PtID %in% bigger_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(4) ~ "Weeks 1-4",
      DeviceDtTm >= Start_time + weeks(4) & DeviceDtTm < Start_time + weeks(8) ~ "Weeks 5-8",
      DeviceDtTm >= Start_time + weeks(8) & DeviceDtTm < Start_time + weeks(12) ~ "Weeks 9-12",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))



# --- Step 2: Transition Matrix Calculation ---
calculate_transitions1 <- function(data, max_gap_mins = 120) {
  data <- data[order(data$DeviceDtTm), ]
  n <- nrow(data)
  if (n < 2 || length(unique(data$Level)) < 2) return(NULL)
  data$time_diff <- c(0, as.numeric(difftime(data$DeviceDtTm[-1], data$DeviceDtTm[-n], units = "mins")))
  valid_idx <- which(data$time_diff[-1] <= max_gap_mins) + 1
  if (length(valid_idx) < 1) return(NULL)
  from_states <- as.character(data$Level[valid_idx - 1])
  to_states <- as.character(data$Level[valid_idx])
  trans_table <- table(from_states, to_states)
  transition_matrix <- prop.table(trans_table, 1)
  # Ensure all levels present
  transition_matrix_full <- matrix(0, length(states_order_long), length(states_order_long),
                                  dimnames = list(states_order_long, states_order_long))
  transition_matrix_full[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix
  transition_matrix_full
}

iobp2_f1 = rbind(base1 %>% dplyr::select(-AgeAsofEnrollDt), iobp2_f1_rct)

individual_transitions_td_base_rct <- iobp2_f1 %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# Step 4: Apply to individuals and group
individual_transitions_td_detail_rct <- iobp2_f1_rct_d %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# --- Step 3: Average Transition Matrix ---
average_transition_matrix <- function(transitions) {
  n_states <- length(states_order_long)
  summed_matrices <- matrix(0, n_states, n_states, dimnames = list(states_order_long, states_order_long))
  state_counts <- setNames(rep(0, n_states), states_order_long)
  for (mat in transitions$transitionMatrix) {
    if (!is.null(mat)) {
      for (state in states_order_long) {
        if (state %in% rownames(mat)) {
          summed_matrices[state, ] <- summed_matrices[state, ] + mat[state, ]
          state_counts[state] <- state_counts[state] + 1
        }
      }
    }
  }
  mean_matrix <- matrix(0, n_states, n_states, dimnames = list(states_order_long, states_order_long))
  for (state in states_order_long) {
    if (state_counts[state] > 0) {
      mean_matrix[state, ] <- summed_matrices[state, ] / state_counts[state]
    }
  }
  mean_matrix
}

# --- Step 4: Helper Functions ---
extract_transition_value <- function(mat, from_state, to_state) {
  if (is.null(mat) || !(from_state %in% rownames(mat) && to_state %in% colnames(mat))) return(NA_real_)
  mat[from_state, to_state]
}

get_stationary_dist <- function(transition_matrix, states) {
  tm <- transition_matrix
  for (i in seq_len(nrow(tm))) {
    row_sum <- sum(tm[i, ], na.rm = TRUE)
    tm[i, ] <- if (row_sum > 0) tm[i, ] / row_sum else 0
  }
  mc <- tryCatch(new("markovchain", states = states, transitionMatrix = tm, name = "Chain"), error = function(e) NULL)
  if (!is.null(mc)) {
    stat <- tryCatch({ as.numeric(steadyStates(mc)[1, ]) }, error = function(e) rep(NA, length(states)))
    names(stat) <- states
    return(stat)
  } else {
    return(rep(NA, length(states)))
  }
}

# --- Step 5: Bootstrap P-Value Calculation ---
bootstrap_cell_pvals <- function(data, from_state, to_state, group1, group2, R = 1000) {
  diffs <- replicate(R, {
    sample_g1 <- sample(unique(data$PtID[data$TrtGroup == group1]), replace = TRUE)
    sample_g2 <- sample(unique(data$PtID[data$TrtGroup == group2]), replace = TRUE)
    mats_g1 <- data %>% filter(PtID %in% sample_g1) %>% pull(transitionMatrix)
    mats_g2 <- data %>% filter(PtID %in% sample_g2) %>% pull(transitionMatrix)
    val_g1 <- mean(map_dbl(mats_g1, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g2 <- mean(map_dbl(mats_g2, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g1 - val_g2
  })
  # two-sided p-value
  2 * min(mean(diffs >= 0, na.rm = TRUE), mean(diffs <= 0, na.rm = TRUE))
}

# --- Step 6: Find Global Color Limits ---
get_group_diff_vals <- function(data, age, periods, group1 = "BP", group2 = "Control") {
  all_diffs <- c()
  for (period in periods) {
    subdata <- data %>% filter(Peds_age == age, Rct_period == period)
    mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
    mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
    tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
    tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
    diff_matrix <- tm_bp - tm_ctrl
    all_diffs <- c(all_diffs, as.vector(diff_matrix))
  }
  max(abs(all_diffs), na.rm = TRUE) %>% round(2) + 0.01
}

# --- Step 7: Plotting Function ---
create_enhanced_heatmap <- function(data, age, period, group1 = "BP", group2 = "Control", R = 1000, global_limit) {
  subdata <- data %>% filter(Peds_age == age, Rct_period == period)
  mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
  mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
  tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
  tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
  marginal_bp <- get_stationary_dist(tm_bp, states_order_long)
  marginal_ctrl <- get_stationary_dist(tm_ctrl, states_order_long)
  fmt_pct <- function(x) sprintf("%.1f%%", pmax(100 * x, 0.1))
  y_labels <- sprintf("%s (%s, %s)", states_order_long, fmt_pct(marginal_ctrl), fmt_pct(marginal_bp))
  names(y_labels) <- states_order_long
  diff_matrix <- tm_bp - tm_ctrl
  diff_df <- as.data.frame(as.table(diff_matrix))
  colnames(diff_df) <- c("From", "To", "Diff")
  diff_df$From <- factor(diff_df$From, levels = states_order_long)
  diff_df$To <- factor(diff_df$To, levels = states_order_long)
  diff_df$Pval <- purrr::pmap_dbl(diff_df[,c("From","To")], function(From, To)
    tryCatch(bootstrap_cell_pvals(subdata, as.character(From), as.character(To), group1, group2, R = R), error = function(e) NA_real_))
  diff_df$Star <- cut(diff_df$Pval, breaks = c(-Inf, 0.001, 0.01, 0.05, Inf), labels = c('***', '**', '*', ''), right = TRUE)
  ggplot(diff_df, aes(x = To, y = From, fill = Diff)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Star), color = "black", size = 6) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         midpoint = 0, limits = c(-global_limit, global_limit),
                         name = "Diff (BP - Control)") +
    scale_y_discrete(labels = y_labels[levels(diff_df$From)]) +
    scale_x_discrete(labels = short_names[levels(diff_df$To)]) +
    labs(
      title = paste0("Age: ", tools::toTitleCase(age), " | Period: ", period),
      x = "To State", y = "From State (Control %, BP %)"
    ) +
    theme_minimal(base_size = 15) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
          axis.text.y = element_text(size = 12))
}

# --- Step 8: Main Loop for All Plots ---
age_groups <- c("adults", "children")
periods <- c("Baseline", "RCT", "Weeks 1-4", "Weeks 5-8", "Weeks 9-12")
global_limits <- list()
for (age in age_groups) {
  global_limits[[age]] <- get_group_diff_vals(
    rbind(individual_transitions_td_base_rct, individual_transitions_td_detail_rct),
    age, periods, "BP", "Control"
  )
}
plot_list <- list()
for (age in age_groups) {
  for (period in periods) {
    plot_list[[paste(age, period, sep = "_")]] <- create_enhanced_heatmap(
      rbind(individual_transitions_td_base_rct, individual_transitions_td_detail_rct),
      age = age, period = period, group1 = "BP", group2 = "Control", R = 1000, global_limit = global_limits[[age]]
    )
  }
}
final_plot <- wrap_plots(plot_list, ncol = 2, byrow = FALSE) +
  plot_annotation(
    title = "Differences in Transition Probabilities (BP - Control) with Significance",
    subtitle = "Separate color scales for Adults and Children. *, **, ***: p < 0.05, 0.01, 0.001"
  )
ggsave("./figures/transition_probability_diff_heatmaps_significance.png", final_plot, width = 16, height = 18, dpi = 300)
final_plot

```

```{r}
# Define helper function to print the matrix differences
print_transition_diff_matrix <- function(data, age, period, group1 = "BP", group2 = "Control") {
  subdata <- data %>% filter(Peds_age == age, Rct_period == period)
  mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
  mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
  tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
  tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
  diff_matrix <- tm_bp - tm_ctrl
  cat("\n--- Difference in transition matrix for", period, "-", age, "(BP - Control) ---\n")
  print(round(diff_matrix, 3))
}

# Apply function for each period and age group
periods <- c("Baseline", "RCT", "Weeks 1-4", "Weeks 5-8", "Weeks 9-12")
age_groups <- c("adults", "children")

for (age in age_groups) {
  for (period in periods) {
    print_transition_diff_matrix(
      rbind(individual_transitions_td_base_rct, individual_transitions_td_detail_rct),
      age, period, "BP", "Control"
    )
  }
}

```


### transition probability. - treatment group -level diff - (heatmap)- limited

```{r, fig.height=12, fig.width=20}
# --- Libraries ---
library(markovchain)
library(dplyr)
library(tidyr)
library(purrr)
library(knitr)
library(ggplot2)
library(patchwork)

# --- States ---
states_order_long <- c(
  "Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
  "Level 1 hyperglycemia", "Level 2 hyperglycemia"
)
short_names <- c(
  "Level 2 hypoglycemia" = "L2 Hypo",
  "Level 1 hypoglycemia" = "L1 Hypo",
  "In range" = "In Range",
  "Level 1 hyperglycemia" = "L1 Hyper",
  "Level 2 hyperglycemia" = "L2 Hyper"
)

# --- Step 1: Prepare Data ---
base2 = iobp2 %>% filter(PtID %in% limited_id) %>% filter(DeviceDtTm < RandDt)%>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

# Filter and label the data
iobp2_f2_rct <- rct %>%
  filter(PtID %in% limited_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(12) ~ "RCT",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

iobp2_f2_rct_d = rct %>%
  filter(PtID %in% limited_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(4) ~ "Weeks 1-4",
      DeviceDtTm >= Start_time + weeks(4) & DeviceDtTm < Start_time + weeks(8) ~ "Weeks 5-8",
      DeviceDtTm >= Start_time + weeks(8) & DeviceDtTm < Start_time + weeks(12) ~ "Weeks 9-12",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))



# --- Step 2: Transition Matrix Calculation ---
calculate_transitions1 <- function(data, max_gap_mins = 120) {
  data <- data[order(data$DeviceDtTm), ]
  n <- nrow(data)
  if (n < 2 || length(unique(data$Level)) < 2) return(NULL)
  data$time_diff <- c(0, as.numeric(difftime(data$DeviceDtTm[-1], data$DeviceDtTm[-n], units = "mins")))
  valid_idx <- which(data$time_diff[-1] <= max_gap_mins) + 1
  if (length(valid_idx) < 1) return(NULL)
  from_states <- as.character(data$Level[valid_idx - 1])
  to_states <- as.character(data$Level[valid_idx])
  trans_table <- table(from_states, to_states)
  transition_matrix <- prop.table(trans_table, 1)
  # Ensure all levels present
  transition_matrix_full <- matrix(0, length(states_order_long), length(states_order_long),
                                  dimnames = list(states_order_long, states_order_long))
  transition_matrix_full[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix
  transition_matrix_full
}

iobp2_f2 = rbind(base2 %>% dplyr::select(-AgeAsofEnrollDt), iobp2_f2_rct)

individual_transitions_td_base_rct_l <- iobp2_f2 %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# Step 4: Apply to individuals and group
individual_transitions_td_detail_rct_l <- iobp2_f2_rct_d %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# --- Step 3: Average Transition Matrix ---
average_transition_matrix <- function(transitions) {
  n_states <- length(states_order_long)
  summed_matrices <- matrix(0, n_states, n_states, dimnames = list(states_order_long, states_order_long))
  state_counts <- setNames(rep(0, n_states), states_order_long)
  for (mat in transitions$transitionMatrix) {
    if (!is.null(mat)) {
      for (state in states_order_long) {
        if (state %in% rownames(mat)) {
          summed_matrices[state, ] <- summed_matrices[state, ] + mat[state, ]
          state_counts[state] <- state_counts[state] + 1
        }
      }
    }
  }
  mean_matrix <- matrix(0, n_states, n_states, dimnames = list(states_order_long, states_order_long))
  for (state in states_order_long) {
    if (state_counts[state] > 0) {
      mean_matrix[state, ] <- summed_matrices[state, ] / state_counts[state]
    }
  }
  mean_matrix
}

# --- Step 4: Helper Functions ---
extract_transition_value <- function(mat, from_state, to_state) {
  if (is.null(mat) || !(from_state %in% rownames(mat) && to_state %in% colnames(mat))) return(NA_real_)
  mat[from_state, to_state]
}

get_stationary_dist <- function(transition_matrix, states) {
  tm <- transition_matrix
  for (i in seq_len(nrow(tm))) {
    row_sum <- sum(tm[i, ], na.rm = TRUE)
    tm[i, ] <- if (row_sum > 0) tm[i, ] / row_sum else 0
  }
  mc <- tryCatch(new("markovchain", states = states, transitionMatrix = tm, name = "Chain"), error = function(e) NULL)
  if (!is.null(mc)) {
    stat <- tryCatch({ as.numeric(steadyStates(mc)[1, ]) }, error = function(e) rep(NA, length(states)))
    names(stat) <- states
    return(stat)
  } else {
    return(rep(NA, length(states)))
  }
}

# --- Step 5: Bootstrap P-Value Calculation ---
bootstrap_cell_pvals <- function(data, from_state, to_state, group1, group2, R = 1000) {
  diffs <- replicate(R, {
    sample_g1 <- sample(unique(data$PtID[data$TrtGroup == group1]), replace = TRUE)
    sample_g2 <- sample(unique(data$PtID[data$TrtGroup == group2]), replace = TRUE)
    mats_g1 <- data %>% filter(PtID %in% sample_g1) %>% pull(transitionMatrix)
    mats_g2 <- data %>% filter(PtID %in% sample_g2) %>% pull(transitionMatrix)
    val_g1 <- mean(map_dbl(mats_g1, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g2 <- mean(map_dbl(mats_g2, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g1 - val_g2
  })
  # two-sided p-value
  2 * min(mean(diffs >= 0, na.rm = TRUE), mean(diffs <= 0, na.rm = TRUE))
}

# --- Step 6: Find Global Color Limits ---
get_group_diff_vals <- function(data, age, periods, group1 = "BP", group2 = "Control") {
  all_diffs <- c()
  for (period in periods) {
    subdata <- data %>% filter(Peds_age == age, Rct_period == period)
    mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
    mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
    tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
    tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
    diff_matrix <- tm_bp - tm_ctrl
    all_diffs <- c(all_diffs, as.vector(diff_matrix))
  }
  max(abs(all_diffs), na.rm = TRUE) %>% round(2) + 0.01
}

# --- Step 7: Plotting Function ---
create_enhanced_heatmap <- function(data, age, period, group1 = "BP", group2 = "Control", R = 1000, global_limit) {
  subdata <- data %>% filter(Peds_age == age, Rct_period == period)
  mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
  mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
  tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
  tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
  marginal_bp <- get_stationary_dist(tm_bp, states_order_long)
  marginal_ctrl <- get_stationary_dist(tm_ctrl, states_order_long)
  fmt_pct <- function(x) sprintf("%.1f%%", pmax(100 * x, 0.1))
  y_labels <- sprintf("%s (%s, %s)", states_order_long, fmt_pct(marginal_ctrl), fmt_pct(marginal_bp))
  names(y_labels) <- states_order_long
  diff_matrix <- tm_bp - tm_ctrl
  diff_df <- as.data.frame(as.table(diff_matrix))
  colnames(diff_df) <- c("From", "To", "Diff")
  diff_df$From <- factor(diff_df$From, levels = states_order_long)
  diff_df$To <- factor(diff_df$To, levels = states_order_long)
  diff_df$Pval <- purrr::pmap_dbl(diff_df[,c("From","To")], function(From, To)
    tryCatch(bootstrap_cell_pvals(subdata, as.character(From), as.character(To), group1, group2, R = R), error = function(e) NA_real_))
  diff_df$Star <- cut(diff_df$Pval, breaks = c(-Inf, 0.001, 0.01, 0.05, Inf), labels = c('***', '**', '*', ''), right = TRUE)
  ggplot(diff_df, aes(x = To, y = From, fill = Diff)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Star), color = "black", size = 6) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         midpoint = 0, limits = c(-global_limit, global_limit),
                         name = "Diff (BP - Control)") +
    scale_y_discrete(labels = y_labels[levels(diff_df$From)]) +
    scale_x_discrete(labels = short_names[levels(diff_df$To)]) +
    labs(
      title = paste0("Age: ", tools::toTitleCase(age), " | Period: ", period),
      x = "To State", y = "From State (Control %, BP %)"
    ) +
    theme_minimal(base_size = 15) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
          axis.text.y = element_text(size = 12))
}

# --- Step 8: Main Loop for All Plots ---
age_groups <- c("adults", "children")
periods <- c("Baseline", "RCT", "Weeks 1-4", "Weeks 5-8", "Weeks 9-12")
global_limits <- list()
for (age in age_groups) {
  global_limits[[age]] <- get_group_diff_vals(
    rbind(individual_transitions_td_base_rct_l, individual_transitions_td_detail_rct_l),
    age, periods, "BP", "Control"
  )
}
plot_list <- list()
for (age in age_groups) {
  for (period in periods) {
    plot_list[[paste(age, period, sep = "_")]] <- create_enhanced_heatmap(
      rbind(individual_transitions_td_base_rct_l, individual_transitions_td_detail_rct_l),
      age = age, period = period, group1 = "BP", group2 = "Control", R = 1000, global_limit = global_limits[[age]]
    )
  }
}
final_plot <- wrap_plots(plot_list, ncol = 2, byrow = FALSE) +
  plot_annotation(
    title = "Differences in Transition Probabilities (BP - Control) with Significance - Double cutoff for PtID",
    subtitle = "Separate color scales for Adults and Children. *, **, ***: p < 0.05, 0.01, 0.001"
  )

ggsave("./figures/transition_probability_diff_heatmaps_significance_limited_id.png",
       final_plot, width = 16, height = 18, dpi = 300)

final_plot

```

```{r, fig.height=12, fig.width=20, eval=FALSE}
library(markovchain)
library(dplyr)
library(tidyr)
library(purrr)
library(knitr)

#min1 = points_baseline %>% filter(actual_points > expected_points_per_week * 2) %>% pull(PtID)
base2 = iobp2 %>% filter(PtID %in% limited_id) %>% filter(DeviceDtTm < RandDt)%>%
  mutate(
    Rct_period = case_when(
      DeviceDtTm < RandDt ~ "Baseline",
      TRUE ~ NA_character_
    )
  ) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

# Filter and label the data
iobp2_f2_rct <- rct %>%
  filter(PtID %in% limited_id) %>%
  group_by(PtID) %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(12) ~ "RCT",
      TRUE ~ NA_character_
    )
  ) %>%
  ungroup() %>%
  filter(!is.na(Rct_period)) %>% 
  mutate(
    Peds_age = if_else(AgeAsofEnrollDt >= 18, "adults", "children")
  ) %>%
  dplyr::select(PtID, DeviceDtTm, Value, RandDt, TrtGroup, Peds_age, Rct_period) %>%
  mutate(Level = factor(case_when(
    Value >= 250 ~ "Level 2 hyperglycemia",
    Value >= 181 ~ "Level 1 hyperglycemia",
    Value >= 70  ~ "In range",
    Value >= 54  ~ "Level 1 hypoglycemia",
    Value <  54  ~ "Level 2 hypoglycemia"
  ), levels = c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
                "Level 1 hyperglycemia", "Level 2 hyperglycemia")))

iobp2_f2_rct_d = iobp2_f2_rct %>%
  mutate(
    Start_time = min(DeviceDtTm),
    Rct_period = case_when(
      DeviceDtTm >= Start_time & DeviceDtTm < Start_time + weeks(4) ~ "Weeks 1-4",
      DeviceDtTm >= Start_time + weeks(4) & DeviceDtTm < Start_time + weeks(8) ~ "Weeks 5-8",
      DeviceDtTm >= Start_time + weeks(8) & DeviceDtTm < Start_time + weeks(12) ~ "Weeks 9-12",
      TRUE ~ NA_character_
    )
  )

# Step 2: Improved function to calculate individual transition matrix with gap exclusion
calculate_transitions1 <- function(data, max_gap_mins = 120) {
  # Order by timestamp
  data <- data[order(data$DeviceDtTm), ]
  n <- nrow(data)
  if (n < 2 || length(unique(data$Level)) < 2) return(NULL)

  # Compute time difference (in minutes) between consecutive points
  data$time_diff <- c(0, as.numeric(difftime(data$DeviceDtTm[-1], data$DeviceDtTm[-n], units = "mins")))

  # Identify valid transitions (gap <= max_gap_mins)
  valid_idx <- which(data$time_diff[-1] <= max_gap_mins) + 1  # +1 because diff shifts index
  if (length(valid_idx) < 1) return(NULL)

  # Subset to valid transitions only
  from_states <- as.character(data$Level[valid_idx - 1])
  to_states <- as.character(data$Level[valid_idx])

  # Build table of observed transitions
  trans_table <- table(from_states, to_states)

  # Convert to probability matrix (Markov chain)
  if (all(dim(trans_table) == 0)) return(NULL)
  transition_matrix <- prop.table(trans_table, 1)

  # Ensure all levels present (even if not observed in this subject)
  desired_order <- c("Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range", "Level 1 hyperglycemia", "Level 2 hyperglycemia")
  transition_matrix_full <- matrix(0, nrow = length(desired_order), ncol = length(desired_order),
                                  dimnames = list(desired_order, desired_order))
  transition_matrix_full[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix

  return(transition_matrix_full)
}

average_transition_matrix_detailed <- function(transitions) {
  desired_order <- c(
    "Level 2 hypoglycemia", "Level 1 hypoglycemia",
    "In range", "Level 1 hyperglycemia", "Level 2 hyperglycemia"
  )
  n_states <- length(desired_order)

  summed_matrices <- matrix(0, n_states, n_states,
                            dimnames = list(desired_order, desired_order))
  state_counts <- setNames(rep(0, n_states), desired_order)

  for (matrix in transitions$transitionMatrix) {
    if (!is.null(matrix)) {
      row_names <- rownames(matrix)
      col_names <- colnames(matrix)
      row_indices <- match(row_names, desired_order)
      col_indices <- match(col_names, desired_order)

      aligned_matrix <- matrix(0, n_states, n_states,
                               dimnames = list(desired_order, desired_order))
      aligned_matrix[row_indices, col_indices] <- matrix

      for (i in seq_along(desired_order)) {
        state <- desired_order[i]
        if (state %in% row_names) {
          summed_matrices[state, ] <- summed_matrices[state, ] + aligned_matrix[state, ]
          state_counts[state] <- state_counts[state] + 1
        }
      }
    }
  }

  mean_matrix <- matrix(0, n_states, n_states,
                        dimnames = list(desired_order, desired_order))
  for (state in desired_order) {
    if (state_counts[state] > 0) {
      mean_matrix[state, ] <- summed_matrices[state, ] / state_counts[state]
    }
  }
  return(mean_matrix)
}
# Step 4: Apply to individuals and group

iobp2_f2 = rbind(base2 %>% dplyr::select(-AgeAsofEnrollDt), iobp2_f2_rct)

individual_transitions_td_base_rct_l <- iobp2_f2 %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# Step 4: Apply to individuals and group
individual_transitions_td_detail_rct_l <- iobp2_f2_rct_d %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()



set.seed(666)

# --- States & Labels ---
states_order_long <- c(
  "Level 2 hypoglycemia", "Level 1 hypoglycemia", "In range",
  "Level 1 hyperglycemia", "Level 2 hyperglycemia"
)
short_names <- c(
  "Level 2 hypoglycemia" = "L2 Hypo",
  "Level 1 hypoglycemia" = "L1 Hypo",
  "In range" = "In Range",
  "Level 1 hyperglycemia" = "L1 Hyper",
  "Level 2 hyperglycemia" = "L2 Hyper"
)

# --- Helper for matrix extraction ---
extract_transition_value <- function(mat, from_state, to_state) {
  if (is.null(mat)) return(NA_real_)
  if (!(from_state %in% rownames(mat) && to_state %in% colnames(mat))) return(NA_real_)
  mat[from_state, to_state]
}

# --- Function to align matrices ---
align_matrix <- function(mat, states) {
  aligned_mat <- matrix(0, length(states), length(states), dimnames = list(states, states))
  if (!is.null(mat)) {
    rows <- intersect(states, rownames(mat))
    cols <- intersect(states, colnames(mat))
    aligned_mat[rows, cols] <- mat[rows, cols]
  }
  aligned_mat
}

# --- Calculate average transition matrix ---
average_transition_matrix <- function(transitions) {
  desired_order <- states_order_long
  n_states <- length(desired_order)
  summed_matrices <- matrix(0, n_states, n_states, dimnames = list(desired_order, desired_order))
  state_counts <- setNames(rep(0, n_states), desired_order)
  for (mat in transitions$transitionMatrix) {
    if (!is.null(mat)) {
      row_names <- rownames(mat)
      col_names <- colnames(mat)
      row_indices <- match(row_names, desired_order)
      col_indices <- match(col_names, desired_order)
      if (all(!is.na(row_indices)) && all(!is.na(col_indices))) {
        aligned_matrix <- matrix(0, n_states, n_states, dimnames = list(desired_order, desired_order))
        aligned_matrix[row_indices, col_indices] <- mat
        for (i in seq_along(desired_order)) {
          state <- desired_order[i]
          if (state %in% row_names) {
            summed_matrices[state, ] <- summed_matrices[state, ] + aligned_matrix[state, ]
            state_counts[state] <- state_counts[state] + 1
          }
        }
      }
    }
  }
  mean_matrix <- matrix(0, n_states, n_states, dimnames = list(desired_order, desired_order))
  for (state in desired_order) {
    if (state_counts[state] > 0) {
      mean_matrix[state, ] <- summed_matrices[state, ] / state_counts[state]
    }
  }
  mean_matrix
}

# --- Bootstrap p-values for each cell (for significance stars) ---
bootstrap_cell_pvals <- function(data, from_state, to_state, group1, group2, R = 1000) {
  diffs <- replicate(R, {
    sample_g1 <- sample(unique(data$PtID[data$TrtGroup == group1]), replace = TRUE)
    sample_g2 <- sample(unique(data$PtID[data$TrtGroup == group2]), replace = TRUE)
    mats_g1 <- data %>% filter(PtID %in% sample_g1) %>% pull(transitionMatrix)
    mats_g2 <- data %>% filter(PtID %in% sample_g2) %>% pull(transitionMatrix)
    val_g1 <- mean(purrr::map_dbl(mats_g1, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g2 <- mean(purrr::map_dbl(mats_g2, ~extract_transition_value(.x, from_state, to_state)), na.rm = TRUE)
    val_g1 - val_g2
  })
  2 * min(mean(diffs >= 0), mean(diffs <= 0))
}

# Function to safely get stationary distribution
get_stationary_dist <- function(transition_matrix, states) {
  # Ensure valid row sums
  tm <- transition_matrix
  for (i in seq_len(nrow(tm))) {
    row_sum <- sum(tm[i, ], na.rm = TRUE)
    if (row_sum > 0) {
      tm[i, ] <- tm[i, ] / row_sum
    } else {
      tm[i, ] <- 0
    }
  }
  mc <- tryCatch(
    new("markovchain", states = states, transitionMatrix = tm, name = "Chain"),
    error = function(e) NULL
  )
  if (!is.null(mc)) {
    stat <- tryCatch({
      s <- steadyStates(mc)
      as.numeric(s[1,])
    }, error = function(e) rep(NA, length(states)))
    names(stat) <- states
    return(stat)
  } else {
    return(rep(NA, length(states)))
  }
}



# ...[PREVIOUS CODE UNCHANGED: functions and data prep]...

# Compute global_limit SEPARATELY for adults and children
get_group_diff_vals <- function(data, age, periods, group1 = "BP", group2 = "Control") {
  all_diffs <- c()
  for (period in periods) {
    subdata <- data %>% filter(Peds_age == age, Rct_period == period)
    mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
    mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
    tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
    tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))
    diff_matrix <- tm_bp - tm_ctrl
    all_diffs <- c(all_diffs, as.vector(diff_matrix))
  }
  max(abs(all_diffs), na.rm = TRUE) %>% round(2) + 0.01
}

age_groups <- c("adults", "children")
periods <- c("Baseline", "RCT", "Weeks 1-4", "Weeks 5-8", "Weeks 9-12")

global_limits <- list()
for (age in age_groups) {
  global_limits[[age]] <- get_group_diff_vals(
    rbind(individual_transitions_td_base_rct_l, individual_transitions_td_detail_rct_l),
    age, periods, "BP", "Control"
  )
}

# --- Function to create enhanced heatmap with given global_limit (as before) ---
create_enhanced_heatmap <- function(data, age, period, group1 = "BP", group2 = "Control", R = 1000, global_limit) {
  subdata <- data %>% filter(Peds_age == age, Rct_period == period)
  mats_bp <- subdata %>% filter(TrtGroup == group1) %>% pull(transitionMatrix)
  mats_ctrl <- subdata %>% filter(TrtGroup == group2) %>% pull(transitionMatrix)
  tm_bp <- average_transition_matrix(tibble(transitionMatrix = mats_bp))
  tm_ctrl <- average_transition_matrix(tibble(transitionMatrix = mats_ctrl))

  marginal_bp <- get_stationary_dist(tm_bp, states_order_long)
  marginal_ctrl <- get_stationary_dist(tm_ctrl, states_order_long)

  fmt_pct <- function(x) {
    x100 <- 100 * x
    x100 <- pmax(x100, 0.1)
    sprintf("%.1f%%", x100)
  }
  y_labels <- sprintf("%s (%s, %s)", states_order_long, fmt_pct(marginal_ctrl), fmt_pct(marginal_bp))
  names(y_labels) <- states_order_long

  diff_matrix <- tm_bp - tm_ctrl
  diff_df <- as.data.frame(as.table(diff_matrix))
  colnames(diff_df) <- c("From", "To", "Diff")
  diff_df$From <- factor(diff_df$From, levels = states_order_long)
  diff_df$To <- factor(diff_df$To, levels = states_order_long)

  diff_df$Pval <- NA_real_
  for (i in 1:nrow(diff_df)) {
    from <- as.character(diff_df$From[i])
    to <- as.character(diff_df$To[i])
    diff_df$Pval[i] <- tryCatch(
      bootstrap_cell_pvals(subdata, from, to, group1, group2, R = R),
      error = function(e) NA_real_
    )
  }
  diff_df$Star <- cut(diff_df$Pval,
                      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
                      labels = c('***', '**', '*', ''),
                      right = TRUE)

  # SHORT X-axis labels
  short_names <- c(
    "Level 2 hypoglycemia" = "L2 Hypo",
    "Level 1 hypoglycemia" = "L1 Hypo",
    "In range" = "In Range",
    "Level 1 hyperglycemia" = "L1 Hyper",
    "Level 2 hyperglycemia" = "L2 Hyper"
  )

  p <- ggplot(diff_df, aes(x = To, y = From, fill = Diff)) +
    geom_tile(color = "white") +
    geom_text(aes(label = Star), color = "black", size = 6) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         midpoint = 0, limits = c(-global_limit, global_limit),
                         name = "Diff (BP - Control)") +
    scale_y_discrete(labels = y_labels[levels(diff_df$From)]) +
    scale_x_discrete(labels = short_names[levels(diff_df$To)]) +
    labs(
      title = paste0("Age: ", tools::toTitleCase(age), " | Period: ", period),
      x = "To State", y = "From State (Control %, BP %)"
    ) +
    theme_minimal(base_size = 15) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
          axis.text.y = element_text(size = 12))
  return(p)
}

# --- Generate plots with separate color scales for adults/children ---
plot_list <- list()
for (age in age_groups) {
  for (period in periods) {
    plot_list[[paste(age, period, sep = "_")]] <- create_enhanced_heatmap(
      rbind(individual_transitions_td_base_rct, individual_transitions_td_detail_rct),
      age = age,
      period = period,
      group1 = "BP",
      group2 = "Control",
      R = 1000,
      global_limit = global_limits[[age]]
    )
  }
}

# --- Combine all plots as before ---
final_plot <- wrap_plots(plot_list, ncol = 2, byrow = FALSE) +
  plot_annotation(
    title = "Differences in Transition Probabilities (BP - Control) with Significance - Double cutoff for PtID",
    subtitle = "Separate color scales for Adults and Children. *, **, ***: p < 0.05, 0.01, 0.001"
  )

ggsave("./figures/transition_probability_diff_heatmaps_significance_limited_id.png",
       final_plot, width = 16, height = 18, dpi = 300)

final_plot

```


### weilcoxon test

```{r, fig.height=10, fig.width=10}
library(dplyr)
library(tidyr)
library(ggplot2)


# Prepare data for iglu package
iglu_ready_data <- iobp2_f1_rct %>%
  rename(id = PtID, time = DeviceDtTm, gl = Value)

# Mean, SD, CV per participant
metrics_df <- iglu_ready_data %>%
  group_by(id) %>%
  summarise(
    mean_glucose = mean(gl, na.rm = TRUE),
    sd_glucose = sd(gl, na.rm = TRUE),
    cv_glucose = 100 * sd(gl, na.rm = TRUE) / mean(gl, na.rm = TRUE), # percent
    pct_below_54 = mean(gl < 54, na.rm = TRUE) * 100,
    pct_in_70_180 = mean(gl >= 70 & gl <= 180, na.rm = TRUE) * 100,
    pct_above_180 = mean(gl > 180, na.rm = TRUE) * 100
  )

# Calculate MODD and MAGE correctly using iglu package functions separately
modd_results <- modd(iglu_ready_data)
mage_results <- mage(iglu_ready_data)

# Join MODD and MAGE results
iglu_metrics <- modd_results %>%
  left_join(mage_results, by = "id")

# Add back participant metadata
participant_info <- iglu_ready_data %>%
  distinct(id, TrtGroup, Rct_period, Peds_age)

iglu_metrics <- iglu_metrics %>%
  left_join(participant_info, by = "id")

iglu_metrics <- iglu_metrics %>%
  left_join(metrics_df, by = "id")
# Transition probabilities calculation
transitions_results <- iobp2_f1_rct %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()


# Combine everything into one final data frame
final_results <- transitions_results %>%
  rename(id = PtID) %>%
  left_join(iglu_metrics, by = c("id", "TrtGroup", "Rct_period", "Peds_age")) %>%
  left_join(HB_results[,c(2,3,7)] %>%
  pivot_wider(names_from = Visit, values_from = Value) %>%
  rename(id = PtID)) %>% filter(Rct_period =="RCT") %>% rename(PtID = id) %>%
  mutate(Randomization = as.numeric(Randomization),
         `Week 6` = `Week 6` %>% as.numeric(),
         `Week 13` = `Week 13` %>% as.numeric())

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_54", "pct_in_70_180", "pct_above_180",
  "Week 6", "Week 13"#"Randomization", 
)

age_groups <- c("adults", "children")

# Wilcoxon test for all, return p-value
get_wilcox_pvalue <- function(x_bp, x_control) {
  x_bp <- na.omit(x_bp)
  x_control <- na.omit(x_control)
  if (length(x_bp) < 3 | length(x_control) < 3) return(NA)
  test <- wilcox.test(x_bp, x_control)
  return(test$p.value)
}

results <- data.frame()

for (age in age_groups) {
  df <- final_results %>% filter(Peds_age == age)
  for (metric in metrics) {
    vals_bp <- df %>% filter(TrtGroup == "BP") %>% pull(metric)
    vals_ctrl <- df %>% filter(TrtGroup == "Control") %>% pull(metric)
    pval <- get_wilcox_pvalue(vals_bp, vals_ctrl)
    results <- rbind(results, data.frame(
      Metric = metric,
      AgeGroup = tools::toTitleCase(age),
      P_value = pval,
      TestUsed = "Wilcoxon"
    ))
  }
}

results$Significance <- ifelse(results$P_value < 0.05, "Significant", "Not significant")
results$Metric <- factor(results$Metric, levels = metrics)

metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)",
  #"Randomization" = "HbA1c at Randomization (%)",
  "Week 6" = "HbA1c at Week 6 (%)",
  "Week 13" = "HbA1c at Week 13 (%)"
)

publication_order <- c(
  "MODD", "MAGE",
  "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_54", "pct_in_70_180", "pct_above_180",
  "Week 6", "Week 13" #"Randomization", 
)

results$Metric_pretty <- factor(metric_labels[as.character(results$Metric)],
                                levels = rev(metric_labels[publication_order]))

# Since all tests are Wilcoxon, use triangle shape for all
results$Shape <- 17 # triangle

forest_plot2 <- ggplot(results, aes(x = P_value, y = Metric_pretty, color = Significance)) +
  geom_point(size = 4) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "blue") +
  facet_wrap(~AgeGroup, ncol = 2) +
  scale_color_manual(values = c("Significant" = "red", "Not significant" = "black")) +
  labs(
    title = "Comparison of Glycemic Metrics: BP vs Control (by Age Group)",
    subtitle = "All p-values from Wilcoxon tests; dashed line at p=0.05",
    x = "P-value", y = NULL
  ) +
  xlim(0, 1) +
  theme_bw(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom",
    strip.background = element_rect(fill = "grey95", color = "black"),
    axis.text.y = element_text(size = 13)
  )     

# Save the plot
ggsave("./figures/ForestPlot_ALL_Test_Pvalues_Wilcoxon.png",
       plot = forest_plot2,
       width = 14, height = 8, dpi = 300)
forest_plot2
```

```{r new, fig.width=8, fig.height=8}
library(dplyr)
library(tidyr)
library(ggplot2)
library(iglu)
# Prepare data for iglu package
iglu_ready_data <- iobp2_f1_rct %>%
  rename(id = PtID, time = DeviceDtTm, gl = Value)

# Mean, SD, CV per participant
metrics_df <- iglu_ready_data %>%
  group_by(id) %>%
  summarise(
    mean_glucose = mean(gl, na.rm = TRUE),
    sd_glucose = sd(gl, na.rm = TRUE),
    cv_glucose = 100 * sd(gl, na.rm = TRUE) / mean(gl, na.rm = TRUE),
    pct_below_54 = mean(gl < 54, na.rm = TRUE) * 100,
    pct_in_70_180 = mean(gl >= 70 & gl <= 180, na.rm = TRUE) * 100,
    pct_above_180 = mean(gl > 180, na.rm = TRUE) * 100
  )

# Calculate MODD and MAGE (assuming iglu package is loaded and available)
modd_results <- modd(iglu_ready_data)
mage_results <- mage(iglu_ready_data)

# Join MODD and MAGE results
iglu_metrics <- modd_results %>%
  left_join(mage_results, by = "id")

# Add participant metadata
participant_info <- iglu_ready_data %>%
  distinct(id, TrtGroup, Rct_period, Peds_age)

iglu_metrics <- iglu_metrics %>%
  left_join(participant_info, by = "id") %>%
  left_join(metrics_df, by = "id")

# Transition probabilities calculation
transitions_results <- iobp2_f1_rct %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()

# Combine everything into one final data frame
final_results <- transitions_results %>%
  rename(id = PtID) %>%
  left_join(iglu_metrics, by = c("id", "TrtGroup", "Rct_period", "Peds_age")) %>%
  left_join(
    HB_results[, c(2,3,7)] %>%
      pivot_wider(names_from = Visit, values_from = Value) %>%
      rename(id = PtID)
  ) %>%
  filter(Rct_period == "RCT") %>%
  rename(PtID = id) %>%
  mutate(
    Randomization = as.numeric(Randomization),
    `Week 6` = as.numeric(`Week 6`)
    # Week 13 not needed!
  )

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_54", "pct_in_70_180", "pct_above_180"
)
publication_order <- metrics

metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)"
)

age_groups <- c("adults", "children")

# Wilcoxon test for all, return p-value
get_wilcox_pvalue <- function(x_bp, x_control) {
  x_bp <- na.omit(x_bp)
  x_control <- na.omit(x_control)
  if (length(x_bp) < 3 | length(x_control) < 3) return(NA)
  test <- wilcox.test(x_bp, x_control)
  return(test$p.value)
}

results <- data.frame()

for (age in age_groups) {
  df <- final_results %>% filter(Peds_age == age)
  for (metric in metrics) {
    vals_bp <- df %>% filter(TrtGroup == "BP") %>% pull(metric)
    vals_ctrl <- df %>% filter(TrtGroup == "Control") %>% pull(metric)
    pval <- get_wilcox_pvalue(vals_bp, vals_ctrl)
    # Calculate medians for directionality
    med_bp <- median(vals_bp, na.rm = TRUE)
    med_ctrl <- median(vals_ctrl, na.rm = TRUE)
    results <- rbind(results, data.frame(
      Metric = metric,
      AgeGroup = tools::toTitleCase(age),
      P_value = pval,
      TestUsed = "Wilcoxon",
      Median_BP = med_bp,
      Median_Control = med_ctrl
    ))
  }
}

results$Significance <- ifelse(results$P_value < 0.05, "Significant", "Not significant")
results$Metric <- factor(results$Metric, levels = metrics)
results$Metric_pretty <- factor(metric_labels[as.character(results$Metric)], levels = rev(metric_labels[publication_order]))
# Directionality: Square = higher in BP; Circle = higher in Control
results$Higher_in <- ifelse(results$Median_BP > results$Median_Control, "BP", "Control")
results$Shape <- ifelse(results$Higher_in == "BP", 15, 16) # 15=square, 16=circle

forest_plot2 <- ggplot(results, aes(x = P_value, y = Metric_pretty, color = Significance, shape = factor(Shape))) +
  geom_point(size = 4) +
  scale_shape_manual(
    values = c(`15` = 15, `16` = 16),
    labels = c("Higher in BP", "Higher in Control")
  ) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "blue") +
  facet_wrap(~AgeGroup, ncol = 2) +
  scale_color_manual(values = c("Significant" = "red", "Not significant" = "black")) +
  labs(
    title = "Comparison of Glycemic Metrics: BP vs Control (by Age Group)",
    subtitle = "All p-values from Wilcoxon tests; Dashed line at p=0.05",
    x = "P-value", y = NULL, shape = NULL
  ) +
  xlim(0, 1) +
  theme_bw(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom",
    strip.background = element_rect(fill = "grey95", color = "black"),
    axis.text.y = element_text(size = 13)
  )   

# Save the plot
ggsave("./figures/ForestPlot_ALL_Test_Pvalues_Wilcoxon_diff.png",plot = forest_plot2, width = 14, height = 8, dpi = 300)
forest_plot2

```

```{r new-with more metircs}
library(dplyr)
library(tidyr)
library(ggplot2)
library(iglu)

# Prepare data for iglu package
iglu_ready_data <- iobp2_f1_rct %>%
  rename(id = PtID, time = DeviceDtTm, gl = Value)

# Mean, SD, CV, and percent in/out of ranges per participant
metrics_df <- iglu_ready_data %>%
  group_by(id) %>%
  summarise(
    mean_glucose = mean(gl, na.rm = TRUE),
    sd_glucose = sd(gl, na.rm = TRUE),
    cv_glucose = 100 * sd(gl, na.rm = TRUE) / mean(gl, na.rm = TRUE),
    pct_below_70 = mean(gl < 70, na.rm = TRUE) * 100,
    pct_below_54 = mean(gl < 54, na.rm = TRUE) * 100,
    pct_in_70_180 = mean(gl >= 70 & gl <= 180, na.rm = TRUE) * 100,
    pct_above_180 = mean(gl > 180, na.rm = TRUE) * 100,
    pct_above_250 = mean(gl > 250, na.rm = TRUE) * 100
  )

# Calculate MODD and MAGE (assuming iglu package is loaded and available)
modd_results <- modd(iglu_ready_data)
mage_results <- mage(iglu_ready_data)

# Join MODD and MAGE results
iglu_metrics <- modd_results %>%
  left_join(mage_results, by = "id")

# Add participant metadata
participant_info <- iglu_ready_data %>%
  distinct(id, TrtGroup, Rct_period, Peds_age)

iglu_metrics <- iglu_metrics %>%
  left_join(participant_info, by = "id") %>%
  left_join(metrics_df, by = "id")

# Transition probabilities calculation
transitions_results <- iobp2_f1_rct %>%
  group_by(PtID, TrtGroup, Rct_period, Peds_age) %>%
  do(transitionMatrix = calculate_transitions1(.)) %>%
  ungroup()

# Combine everything into one final data frame
final_results <- transitions_results %>%
  rename(id = PtID) %>%
  left_join(iglu_metrics, by = c("id", "TrtGroup", "Rct_period", "Peds_age")) %>%
  left_join(
    HB_results[, c(2,3,7)] %>%
      pivot_wider(names_from = Visit, values_from = Value) %>%
      rename(id = PtID)
  ) %>%
  filter(Rct_period == "RCT") %>%
  rename(PtID = id) %>%
  mutate(
    Randomization = as.numeric(Randomization),
    `Week 6` = as.numeric(`Week 6`)
    # Week 13 not needed!
  )

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_70", "pct_below_54", "pct_in_70_180", "pct_above_180", "pct_above_250"
)
publication_order <- metrics

metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_70" = "Time <70 mg/dL (%)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)",
  "pct_above_250" = "Time >250 mg/dL (%)"
)

age_groups <- c("adults", "children")

# Wilcoxon test for all, return p-value
get_wilcox_pvalue <- function(x_bp, x_control) {
  x_bp <- na.omit(x_bp)
  x_control <- na.omit(x_control)
  if (length(x_bp) < 3 | length(x_control) < 3) return(NA)
  test <- wilcox.test(x_bp, x_control)
  return(test$p.value)
}

results <- data.frame()

for (age in age_groups) {
  df <- final_results %>% filter(Peds_age == age)
  for (metric in metrics) {
    vals_bp <- df %>% filter(TrtGroup == "BP") %>% pull(metric)
    vals_ctrl <- df %>% filter(TrtGroup == "Control") %>% pull(metric)
    pval <- get_wilcox_pvalue(vals_bp, vals_ctrl)
    # Calculate medians for directionality
    med_bp <- median(vals_bp, na.rm = TRUE)
    med_ctrl <- median(vals_ctrl, na.rm = TRUE)
    results <- rbind(results, data.frame(
      Metric = metric,
      AgeGroup = tools::toTitleCase(age),
      P_value = pval,
      TestUsed = "Wilcoxon",
      Median_BP = med_bp,
      Median_Control = med_ctrl
    ))
  }
}

results$Significance <- ifelse(results$P_value < 0.05, "Significant", "Not significant")
results$Metric <- factor(results$Metric, levels = metrics)
results$Metric_pretty <- factor(metric_labels[as.character(results$Metric)], levels = rev(metric_labels[publication_order]))
# Directionality: Square = higher in BP; Circle = higher in Control
results$Higher_in <- ifelse(results$Median_BP > results$Median_Control, "BP", "Control")
results$Shape <- ifelse(results$Higher_in == "BP", 15, 16) # 15=square, 16=circle

forest_plot2 <- ggplot(results, aes(x = P_value, y = Metric_pretty, color = Significance, shape = factor(Shape))) +
  geom_point(size = 4) +
  scale_shape_manual(
    values = c(`15` = 15, `16` = 16),
    labels = c("■ Higher in BP", "● Higher in Control")
  ) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "blue") +
  facet_wrap(~AgeGroup, ncol = 2) +
  scale_color_manual(values = c("Significant" = "red", "Not significant" = "black")) +
  labs(
    title = "Comparison of Glycemic Metrics: BP vs Control (by Age Group)",
    subtitle = "All p-values from Wilcoxon tests; ■ higher in BP, ● higher in Control; dashed line at p=0.05",
    x = "P-value", y = NULL, shape = NULL
  ) +
  xlim(0, 1) +
  theme_bw(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom",
    strip.background = element_rect(fill = "grey95", color = "black"),
    axis.text.y = element_text(size = 13)
  )

# Save the plot
ggsave("./figures/ForestPlot_ALL_Test_Pvalues_Wilcoxon_diff.png", plot = forest_plot2, width = 14, height = 8, dpi = 300)
forest_plot2

```


### Forest - p-value
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_54", "pct_in_70_180", "pct_above_180",
  "Week 6", "Week 13" #"Randomization", 
)
age_groups <- c("adults", "children")


# Function to pick test and return p-value
get_pvalue <- function(x_bp, x_control) {
  # Remove NAs
  x_bp <- na.omit(x_bp)
  x_control <- na.omit(x_control)
  if(length(x_bp) < 3 | length(x_control) < 3) return(NA) # Too few data
  # Shapiro for both groups (normal if p > 0.05)
  normal_bp <- tryCatch(shapiro.test(x_bp)$p.value > 0.05, error = function(e) FALSE)
  normal_ctrl <- tryCatch(shapiro.test(x_control)$p.value > 0.05, error = function(e) FALSE)
  if (normal_bp && normal_ctrl) {
    test <- t.test(x_bp, x_control)
    return(test$p.value)
  } else {
    test <- wilcox.test(x_bp, x_control)
    return(test$p.value)
  }
}


results <- data.frame()

for (age in age_groups) {
  df <- final_results %>% filter(Peds_age == age)
  for (metric in metrics) {
    vals_bp <- df %>% filter(TrtGroup == "BP") %>% pull(metric)
    vals_ctrl <- df %>% filter(TrtGroup == "Control") %>% pull(metric)
    pval <- get_pvalue(vals_bp, vals_ctrl)
    results <- rbind(results, data.frame(
      Metric = metric,
      AgeGroup = tools::toTitleCase(age),
      P_value = pval
    ))
  }
}

results$Significance <- ifelse(results$P_value < 0.05, "Significant", "Not significant")


results$Metric <- factor(results$Metric, levels = metrics)


metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)",
  #"Randomization" = "HbA1c at Randomization (%)",
  "Week 6" = "HbA1c at Week 6 (%)",
  "Week 13" = "HbA1c at Week 13 (%)"
)
# Order: CGM variability metrics, then mean/SD/CV, then %s, then HbA1c
publication_order <- c(
  "MODD", "MAGE",
  "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_54", "pct_in_70_180", "pct_above_180",
  "Week 6", "Week 13" #"Randomization", 
)

results$Metric_pretty <- metric_labels[as.character(results$Metric)]
results$Metric_pretty <- factor(results$Metric_pretty, levels = metric_labels[publication_order])

# For publication, reverse order so the most important metric is at top:
results$Metric_pretty <- factor(results$Metric_pretty, levels = rev(levels(results$Metric_pretty)))


forest_plot2 <- ggplot(results, aes(x = P_value, y = Metric_pretty, color = Significance)) +
  geom_point(size = 4, shape = 18) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "blue") +
  facet_wrap(~AgeGroup, ncol = 2) +
  scale_color_manual(values = c("Significant" = "red", "Not significant" = "black")) +
  labs(title = "Comparison of Glycemic Metrics: BP vs Control (by Age Group) - Test Statistics",
       subtitle = "Dashed line indicates p-value = 0.05 threshold",
       x = "P-value", y = NULL) +
  xlim(0, 1) +
  theme_bw(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom",
    strip.background = element_rect(fill = "grey95", color = "black"),
    axis.text.y = element_text(size = 13)
  )

ggsave("./figures/ForestPlot_ALL_Test_Pvalues.png",
       plot = forest_plot2,
       width = 14, height = 8, dpi = 300)

```

```{r new-metcis}
### Forest - p-value

library(dplyr)
library(tidyr)
library(ggplot2)

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_70", "pct_below_54", "pct_in_70_180", "pct_above_180", "pct_above_250"
)
age_groups <- c("adults", "children")

# Function to pick test and return p-value
get_pvalue <- function(x_bp, x_control) {
  # Remove NAs
  x_bp <- na.omit(x_bp)
  x_control <- na.omit(x_control)
  if(length(x_bp) < 3 | length(x_control) < 3) return(NA) # Too few data
  # Shapiro for both groups (normal if p > 0.05)
  normal_bp <- tryCatch(shapiro.test(x_bp)$p.value > 0.05, error = function(e) FALSE)
  normal_ctrl <- tryCatch(shapiro.test(x_control)$p.value > 0.05, error = function(e) FALSE)
  if (normal_bp && normal_ctrl) {
    test <- t.test(x_bp, x_control)
    return(test$p.value)
  } else {
    test <- wilcox.test(x_bp, x_control)
    return(test$p.value)
  }
}

results <- data.frame()

for (age in age_groups) {
  df <- final_results %>% filter(Peds_age == age)
  for (metric in metrics) {
    vals_bp <- df %>% filter(TrtGroup == "BP") %>% pull(metric)
    vals_ctrl <- df %>% filter(TrtGroup == "Control") %>% pull(metric)
    pval <- get_pvalue(vals_bp, vals_ctrl)
    results <- rbind(results, data.frame(
      Metric = metric,
      AgeGroup = tools::toTitleCase(age),
      P_value = pval
    ))
  }
}

results$Significance <- ifelse(results$P_value < 0.05, "Significant", "Not significant")
results$Metric <- factor(results$Metric, levels = metrics)

metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_70" = "Time <70 mg/dL (%)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)",
  "pct_above_250" = "Time >250 mg/dL (%)"
)

# Order: variability metrics, then mean/SD/CV, then %s (low to high)
publication_order <- c(
  "MODD", "MAGE",
  "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_70", "pct_below_54", "pct_in_70_180", "pct_above_180", "pct_above_250"
)

results$Metric_pretty <- metric_labels[as.character(results$Metric)]
results$Metric_pretty <- factor(results$Metric_pretty, levels = metric_labels[publication_order])
# Reverse order so the most important metric is at the top:
results$Metric_pretty <- factor(results$Metric_pretty, levels = rev(levels(results$Metric_pretty)))

forest_plot2 <- ggplot(results, aes(x = P_value, y = Metric_pretty, color = Significance)) +
  geom_point(size = 4, shape = 18) +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "blue") +
  facet_wrap(~AgeGroup, ncol = 2) +
  scale_color_manual(values = c("Significant" = "red", "Not significant" = "black")) +
  labs(
    title = "Comparison of Glycemic Metrics: BP vs Control (by Age Group) - Test Statistics",
    subtitle = "Dashed line indicates p-value = 0.05 threshold",
    x = "P-value", y = NULL
  ) +
  xlim(0, 1) +
  theme_bw(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom",
    strip.background = element_rect(fill = "grey95", color = "black"),
    axis.text.y = element_text(size = 13)
  )

ggsave("./figures/ForestPlot_ALL_Test_Pvalues.png",
       plot = forest_plot2,
       width = 14, height = 8, dpi = 300)

forest_plot2


```


## Hist check for test
```{r, fig.height=20, fig.width=6}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(ggpubr)

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_54", "pct_in_70_180", "pct_above_180",
  "Week 6", "Week 13" #"Randomization", 
)

age_groups <- c("adults", "children")

# Scientific metric labels for clarity
metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)",
  "Randomization" = "HbA1c at Randomization (%)",
  "Week 6" = "HbA1c at Week 6 (%)",
  "Week 13" = "HbA1c at Week 13 (%)"
)

# Professional colors for BP vs Control
colors <- c("BP" = "#4E79A7", "Control" = "#F28E2B")

plot_list <- list()

# Generate density plots with embedded Shapiro-Wilk test results
for (metric in metrics) {
  for (age in age_groups) {
    subdat <- final_results %>%
      filter(Peds_age == age) %>%
      select(TrtGroup, value = all_of(metric)) %>%
      na.omit()

    # Compute Shapiro–Wilk p-values
    shapiro_pvals <- subdat %>%
      group_by(TrtGroup) %>%
      summarise(p_value = if(n() >= 3) shapiro.test(value)$p.value else NA) %>%
      mutate(normality = ifelse(p_value > 0.05, "Normal", "Not normal"),
             label = paste0(TrtGroup, ": p = ", round(p_value, 3), 
                            " (", normality, ")"))

    label_text <- paste(shapiro_pvals$label, collapse = "\n")

    p <- ggplot(subdat, aes(x = value, fill = TrtGroup)) +
      geom_histogram(aes(y = ..density..), alpha = 0.6, color = "grey20", position = "identity") +
      scale_fill_manual(values = colors) +
      labs(
        title = metric_labels[[metric]],
        subtitle = paste0("Age Group: ", tools::toTitleCase(age)),
        x = metric_labels[[metric]],
        y = "Density"
      ) +
      theme_classic(base_size = 13) +
      theme(
        legend.position = "top",
        plot.title = element_text(face = "bold", size = 12),
        plot.subtitle = element_text(size = 10),
        axis.text = element_text(size = 9)
      ) +
      annotate(
        "text", 
        x = Inf, y = Inf, 
        label = label_text, 
        hjust = 1.05, vjust = 1.05, 
        size = 2.8, 
        color = "black"
      )

    plot_list[[paste(metric, age)]] <- p
  }
}

# Arrange plots into pages for the scientific paper
# Displaying first 6 plots as an example; adjust accordingly
kk = wrap_plots(plot_list, ncol = 4, byrow = TRUE) + plot_annotation(
  title = "Distribution of Glycemic Metrics by Treatment Group and Age",
  subtitle = "Histograms for bionic pancreas (BP) and control, stratified by adults and children. Shapiro–Wilk p-values for normality are annotated in each panel."
)

ggsave("./figures/Hist_ALL_Test_Pvalues.png",
       plot = kk,
       width = 15, height = 18, dpi = 300)
kk
```

## Hist check for test
```{r new hist, fig.height=20, fig.width=6}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(ggpubr)

metrics <- c(
  "MODD", "MAGE", "mean_glucose", "sd_glucose", "cv_glucose",
  "pct_below_70", "pct_below_54", "pct_in_70_180", "pct_above_180", "pct_above_250"
)
age_groups <- c("adults", "children")

metric_labels <- c(
  "MODD" = "Mean of Daily Differences (MODD)",
  "MAGE" = "Mean Amplitude of Glycemic Excursions (MAGE)",
  "mean_glucose" = "Mean Glucose (mg/dL)",
  "sd_glucose" = "Standard Deviation (SD, mg/dL)",
  "cv_glucose" = "Coefficient of Variation (CV, %)",
  "pct_below_70" = "Time <70 mg/dL (%)",
  "pct_below_54" = "Time <54 mg/dL (%)",
  "pct_in_70_180" = "Time in 70–180 mg/dL (%)",
  "pct_above_180" = "Time >180 mg/dL (%)",
  "pct_above_250" = "Time >250 mg/dL (%)"
)

colors <- c("BP" = "#4E79A7", "Control" = "#F28E2B")

plot_list <- list()

# Generate density plots with embedded Shapiro-Wilk test results
for (metric in metrics) {
  for (age in age_groups) {
    subdat <- final_results %>%
      filter(Peds_age == age) %>%
      select(TrtGroup, value = all_of(metric)) %>%
      na.omit()

    # Compute Shapiro–Wilk p-values
    shapiro_pvals <- subdat %>%
      group_by(TrtGroup) %>%
      summarise(p_value = if(n() >= 3) shapiro.test(value)$p.value else NA) %>%
      mutate(
        normality = ifelse(p_value > 0.05, "Normal", "Not normal"),
        label = paste0(TrtGroup, ": p = ", round(p_value, 3), " (", normality, ")")
      )

    label_text <- paste(shapiro_pvals$label, collapse = "\n")

    p <- ggplot(subdat, aes(x = value, fill = TrtGroup)) +
      geom_histogram(aes(y = ..density..), alpha = 0.6, color = "grey20", position = "identity") +
      scale_fill_manual(values = colors) +
      labs(
        title = metric_labels[[metric]],
        subtitle = paste0("Age Group: ", tools::toTitleCase(age)),
        x = metric_labels[[metric]],
        y = "Density"
      ) +
      theme_classic(base_size = 13) +
      theme(
        legend.position = "top",
        plot.title = element_text(face = "bold", size = 12),
        plot.subtitle = element_text(size = 10),
        axis.text = element_text(size = 9)
      ) +
      annotate(
        "text", 
        x = Inf, y = Inf, 
        label = label_text, 
        hjust = 1.05, vjust = 1.05, 
        size = 2.8, 
        color = "black"
      )

    plot_list[[paste(metric, age)]] <- p
  }
}

# Arrange plots into a grid
kk = wrap_plots(plot_list, ncol = 4, byrow = TRUE) + plot_annotation(
  title = "Distribution of Glycemic Metrics by Treatment Group and Age",
  subtitle = "Histograms for bionic pancreas (BP) and control, stratified by adults and children. Shapiro–Wilk p-values for normality are annotated in each panel."
)

ggsave("./figures/Hist_ALL_Test_Pvalues.png",
       plot = kk,
       width = 15, height = 18, dpi = 300)
kk
```